[
    {
        "text_widget_id": 1970638992,
        "sequence": "EditorTextCreated",
        "text_widget_class": "CodeViewText",
        "editor_id": 1970556176,
        "time": "2018-07-19T21:08:43.101782",
        "editor_class": "Editor"
    },
    {
        "text_widget_id": 1970638992,
        "sequence": "Open",
        "text_widget_class": "CodeViewText",
        "editor_id": 1970556176,
        "time": "2018-07-19T21:08:43.102780",
        "filename": "/home/pi/socketserver.py",
        "editor_class": "Editor"
    },
    {
        "index1": "1.0",
        "sequence": "TextDelete",
        "text_widget_class": "CodeViewText",
        "time": "2018-07-19T21:08:43.170717",
        "text_widget_id": 1970638992,
        "index2": "2.0"
    },
    {
        "text_widget_id": 1970638992,
        "index": "1.0",
        "text_widget_class": "CodeViewText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:08:43.186751",
        "tags": "()",
        "text": "import socket\n\nHOST = \"192.168.20.92\"\nPORT = 8888\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nprint ('Socket created')\ns.bind((HOST, PORT))\nprint ('Socket bind complete')\ns.listen(1)\nprint ('Socket now listening')\n\n# pi control function\ndef do_some_stuffs_with_input(input_string):\n\t#Raspberry Pi control\n\tif input_string == \"left\":\n\t\tinput_string = \"\uc11c\ubcf4\ubaa8\ud130 \uc88c\ud68c\uc804 \ud569\ub2c8\ub2e4.\"\n\t\t#\ud30c\uc774 \ub3d9\uc791 \uba85\ub839 \ucd94\uac00\ud560\uac83\n\telif input_string == \"right\":\n\t\tinput_string = \"\uc11c\ubcf4\ubaa8\ud130 \uc6b0\ud68c\uc804 \ud569\ub2c8\ub2e4.\"\n\telif input_string == \"single\":\n\t\tinput_string = \"\uc0ac\uc9c4\uc744 \ucc0d\uc2b5\ub2c8\ub2e4.\"\n\telse :\n\t\tinput_string = input_string + \" \uc5c6\ub294 \uba85\ub839\uc5b4 \uc785\ub2c8\ub2e4.\"\n\treturn input_string\n\nwhile True:\n\t#\uc811\uc18d \uc2b9\uc778\n\tconn, addr = s.accept()\n\tprint(\"Connected by \", addr)\n\n\t#\ub370\uc774\ud130 \uc218\uc2e0\n\tdata = conn.recv(1024)\n\tdata = data.decode(\"utf8\").strip()\n\tif not data: break\n\tprint(\"Received: \" + data)\n\n\t#\uc218\uc2e0\ud55c \ub370\uc774\ud130\ub85c \ud30c\uc774\ub97c \ucee8\ud2b8\ub864 \n\tres = do_some_stuffs_with_input(data)\n\tprint(\"\ud30c\uc774 \ub3d9\uc791 :\" + res)\n\n\t#\ud074\ub77c\uc774\uc5b8\ud2b8\uc5d0\uac8c \ub2f5\uc744 \ubcf4\ub0c4\n\tconn.sendall(res.encode(\"utf-8\"))\n\t#\uc5f0\uacb0 \ub2eb\uae30\n\tconn.close()\ns.close()\n[\ucd9c\ucc98] \uc548\ub4dc\ub85c\uc774\ub4dc \uc2a4\ud29c\ub514\uc624 - \ub77c\uc988\ubca0\ub9ac\ud30c\uc774 \uce74\uba54\ub77c\uc640 UV4L\ub85c \uc2a4\ud2b8\ub9ac\ubc0d \uc571 \ub9cc\ub4e4\uae30(3) : \uc18c\ucf13\ud1b5\uc2e0|\uc791\uc131\uc790 \ucf54\uc2a4\ubaa8\uc2a4"
    },
    {
        "view_class": "ShellView",
        "sequence": "ShowView",
        "view_id": "ShellView",
        "time": "2018-07-19T21:08:43.200104"
    },
    {
        "sequence": "<FocusIn>",
        "widget_class": "Workbench",
        "widget_id": 1982950640,
        "time": "2018-07-19T21:08:43.447829"
    },
    {
        "text_widget_id": 1970495696,
        "index": "1.0",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:08:43.457883",
        "tags": "('welcome',)",
        "text_widget_context": "shell",
        "text": "Python 3.5.3 (/usr/bin/python3)"
    },
    {
        "text_widget_id": 1970495696,
        "index": "1.31",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:08:43.460727",
        "tags": "('io',)",
        "text_widget_context": "shell",
        "text": "\n"
    },
    {
        "text_widget_id": 1970495696,
        "index": "2.0",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:08:43.462078",
        "tags": "('toplevel', 'prompt')",
        "text_widget_context": "shell",
        "text": ">>> "
    },
    {
        "text_widget_id": 1970638992,
        "sequence": "<Button-1>",
        "text_widget_class": "CodeViewText",
        "widget_id": 1970638992,
        "time": "2018-07-19T21:08:43.982348",
        "widget_class": "CodeViewText"
    },
    {
        "text_widget_id": 1970638992,
        "sequence": "<Button-1>",
        "text_widget_class": "CodeViewText",
        "widget_id": 1970638992,
        "time": "2018-07-19T21:09:39.544410",
        "widget_class": "CodeViewText"
    },
    {
        "text_widget_id": 1970638992,
        "index": "2.0",
        "text_widget_class": "CodeViewText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:09:40.415731",
        "tags": "None",
        "text": "i"
    },
    {
        "text_widget_id": 1970638992,
        "index": "2.1",
        "text_widget_class": "CodeViewText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:09:41.057425",
        "tags": "None",
        "text": "m"
    },
    {
        "text_widget_id": 1970638992,
        "index": "2.2",
        "text_widget_class": "CodeViewText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:09:41.259359",
        "tags": "None",
        "text": "p"
    },
    {
        "text_widget_id": 1970638992,
        "index": "2.3",
        "text_widget_class": "CodeViewText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:09:41.422431",
        "tags": "None",
        "text": "o"
    },
    {
        "text_widget_id": 1970638992,
        "index": "2.4",
        "text_widget_class": "CodeViewText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:09:41.476936",
        "tags": "None",
        "text": "r"
    },
    {
        "text_widget_id": 1970638992,
        "index": "2.5",
        "text_widget_class": "CodeViewText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:09:41.636086",
        "tags": "None",
        "text": "t"
    },
    {
        "text_widget_id": 1970638992,
        "index": "2.6",
        "text_widget_class": "CodeViewText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:09:41.728054",
        "tags": "None",
        "text": " "
    },
    {
        "text_widget_id": 1970638992,
        "index": "2.7",
        "text_widget_class": "CodeViewText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:09:42.034670",
        "tags": "None",
        "text": "f"
    },
    {
        "text_widget_id": 1970638992,
        "index": "2.8",
        "text_widget_class": "CodeViewText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:09:42.178079",
        "tags": "None",
        "text": "u"
    },
    {
        "text_widget_id": 1970638992,
        "index": "2.9",
        "text_widget_class": "CodeViewText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:09:44.123476",
        "tags": "None",
        "text": "n"
    },
    {
        "text_widget_id": 1970638992,
        "index": "2.10",
        "text_widget_class": "CodeViewText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:09:44.250798",
        "tags": "None",
        "text": "c"
    },
    {
        "text_widget_id": 1970638992,
        "index": "2.11",
        "text_widget_class": "CodeViewText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:09:44.515520",
        "tags": "None",
        "text": "t"
    },
    {
        "text_widget_id": 1970638992,
        "index": "2.12",
        "text_widget_class": "CodeViewText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:09:44.610882",
        "tags": "None",
        "text": "i"
    },
    {
        "text_widget_id": 1970638992,
        "index": "2.13",
        "text_widget_class": "CodeViewText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:09:44.830141",
        "tags": "None",
        "text": "o"
    },
    {
        "text_widget_id": 1970638992,
        "index": "2.14",
        "text_widget_class": "CodeViewText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:09:45.080336",
        "tags": "None",
        "text": "n"
    },
    {
        "text_widget_id": 1970638992,
        "index": "2.15",
        "text_widget_class": "CodeViewText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:09:45.690492",
        "tags": "None",
        "text": " "
    },
    {
        "index1": "2.15",
        "sequence": "TextDelete",
        "text_widget_class": "CodeViewText",
        "time": "2018-07-19T21:09:46.952632",
        "text_widget_id": 1970638992,
        "index2": "None"
    },
    {
        "index1": "2.14",
        "sequence": "TextDelete",
        "text_widget_class": "CodeViewText",
        "time": "2018-07-19T21:09:47.463463",
        "text_widget_id": 1970638992,
        "index2": "None"
    },
    {
        "index1": "2.13",
        "sequence": "TextDelete",
        "text_widget_class": "CodeViewText",
        "time": "2018-07-19T21:09:47.986073",
        "text_widget_id": 1970638992,
        "index2": "None"
    },
    {
        "index1": "2.12",
        "sequence": "TextDelete",
        "text_widget_class": "CodeViewText",
        "time": "2018-07-19T21:09:48.048478",
        "text_widget_id": 1970638992,
        "index2": "None"
    },
    {
        "index1": "2.11",
        "sequence": "TextDelete",
        "text_widget_class": "CodeViewText",
        "time": "2018-07-19T21:09:48.058018",
        "text_widget_id": 1970638992,
        "index2": "None"
    },
    {
        "index1": "2.10",
        "sequence": "TextDelete",
        "text_widget_class": "CodeViewText",
        "time": "2018-07-19T21:09:48.097874",
        "text_widget_id": 1970638992,
        "index2": "None"
    },
    {
        "index1": "2.9",
        "sequence": "TextDelete",
        "text_widget_class": "CodeViewText",
        "time": "2018-07-19T21:09:48.136925",
        "text_widget_id": 1970638992,
        "index2": "None"
    },
    {
        "index1": "2.8",
        "sequence": "TextDelete",
        "text_widget_class": "CodeViewText",
        "time": "2018-07-19T21:09:48.146348",
        "text_widget_id": 1970638992,
        "index2": "None"
    },
    {
        "index1": "2.7",
        "sequence": "TextDelete",
        "text_widget_class": "CodeViewText",
        "time": "2018-07-19T21:09:48.184221",
        "text_widget_id": 1970638992,
        "index2": "None"
    },
    {
        "index1": "2.6",
        "sequence": "TextDelete",
        "text_widget_class": "CodeViewText",
        "time": "2018-07-19T21:09:48.222516",
        "text_widget_id": 1970638992,
        "index2": "None"
    },
    {
        "index1": "2.5",
        "sequence": "TextDelete",
        "text_widget_class": "CodeViewText",
        "time": "2018-07-19T21:09:48.258746",
        "text_widget_id": 1970638992,
        "index2": "None"
    },
    {
        "index1": "2.4",
        "sequence": "TextDelete",
        "text_widget_class": "CodeViewText",
        "time": "2018-07-19T21:09:48.268243",
        "text_widget_id": 1970638992,
        "index2": "None"
    },
    {
        "index1": "2.3",
        "sequence": "TextDelete",
        "text_widget_class": "CodeViewText",
        "time": "2018-07-19T21:09:48.308029",
        "text_widget_id": 1970638992,
        "index2": "None"
    },
    {
        "index1": "2.2",
        "sequence": "TextDelete",
        "text_widget_class": "CodeViewText",
        "time": "2018-07-19T21:09:48.346119",
        "text_widget_id": 1970638992,
        "index2": "None"
    },
    {
        "index1": "2.1",
        "sequence": "TextDelete",
        "text_widget_class": "CodeViewText",
        "time": "2018-07-19T21:09:48.378985",
        "text_widget_id": 1970638992,
        "index2": "None"
    },
    {
        "index1": "2.0",
        "sequence": "TextDelete",
        "text_widget_class": "CodeViewText",
        "time": "2018-07-19T21:09:48.417162",
        "text_widget_id": 1970638992,
        "index2": "None"
    },
    {
        "sequence": "<FocusOut>",
        "widget_class": "Workbench",
        "widget_id": 1982950640,
        "time": "2018-07-19T21:09:50.703840"
    },
    {
        "text_widget_id": 1951847280,
        "sequence": "EditorTextCreated",
        "text_widget_class": "CodeViewText",
        "editor_id": 1951850160,
        "time": "2018-07-19T21:10:19.281250",
        "editor_class": "Editor"
    },
    {
        "text_widget_id": 1951847280,
        "sequence": "Open",
        "text_widget_class": "CodeViewText",
        "editor_id": 1951850160,
        "time": "2018-07-19T21:10:19.282317",
        "filename": "/home/pi/functions.py",
        "editor_class": "Editor"
    },
    {
        "index1": "1.0",
        "sequence": "TextDelete",
        "text_widget_class": "CodeViewText",
        "time": "2018-07-19T21:10:19.284642",
        "text_widget_id": 1951847280,
        "index2": "2.0"
    },
    {
        "text_widget_id": 1951847280,
        "index": "1.0",
        "text_widget_class": "CodeViewText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:10:19.285024",
        "tags": "()",
        "text": ""
    },
    {
        "sequence": "<FocusIn>",
        "widget_class": "Workbench",
        "widget_id": 1982950640,
        "time": "2018-07-19T21:10:28.084392"
    },
    {
        "sequence": "<Button-1>",
        "widget_class": "EditorNotebook",
        "widget_id": 1970459376,
        "time": "2018-07-19T21:10:29.624557"
    },
    {
        "sequence": "<Button-1>",
        "widget_class": "EditorNotebook",
        "widget_id": 1970459376,
        "time": "2018-07-19T21:10:30.709741"
    },
    {
        "text_widget_id": 1951847280,
        "sequence": "<Button-1>",
        "text_widget_class": "CodeViewText",
        "widget_id": 1951847280,
        "time": "2018-07-19T21:10:31.269689",
        "widget_class": "CodeViewText"
    },
    {
        "text_widget_id": 1951847280,
        "index": "1.0",
        "text_widget_class": "CodeViewText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:10:31.558293",
        "tags": "None",
        "text": "import RPi.GPIO as GPIO\nimport time\n\nGPIO.setmode(GPIO.BOARD)\nGPIO.setup(7,GPIO.OUT)\ntry: \n\twhile True:\n\t\tGPIO.output(7,1)\n\t\ttime.sleep(0.00015)\n\t\tGPIO.output(7,0)\n\t#time.sleep(1)\n\nexcept KeyboardInterrupt:\n\tGPIO.cleanup()\n"
    },
    {
        "text_widget_id": 1951847280,
        "sequence": "<<Paste>>",
        "text_widget_class": "CodeViewText",
        "widget_id": 1951847280,
        "time": "2018-07-19T21:10:31.560235",
        "widget_class": "CodeViewText"
    },
    {
        "text_widget_id": 1951847280,
        "sequence": "<Button-1>",
        "text_widget_class": "CodeViewText",
        "widget_id": 1951847280,
        "time": "2018-07-19T21:10:33.182657",
        "widget_class": "CodeViewText"
    },
    {
        "text_widget_id": 1951847280,
        "index": "3.0",
        "text_widget_class": "CodeViewText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:10:34.369830",
        "tags": "None",
        "text": "\n"
    },
    {
        "text_widget_id": 1951847280,
        "index": "4.0",
        "text_widget_class": "CodeViewText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:10:34.542980",
        "tags": "None",
        "text": "\n"
    },
    {
        "text_widget_id": 1951847280,
        "index": "5.0",
        "text_widget_class": "CodeViewText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:10:34.709495",
        "tags": "None",
        "text": "d"
    },
    {
        "text_widget_id": 1951847280,
        "index": "5.1",
        "text_widget_class": "CodeViewText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:10:34.873945",
        "tags": "None",
        "text": "e"
    },
    {
        "text_widget_id": 1951847280,
        "index": "5.2",
        "text_widget_class": "CodeViewText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:10:35.077491",
        "tags": "None",
        "text": "f"
    },
    {
        "text_widget_id": 1951847280,
        "index": "5.3",
        "text_widget_class": "CodeViewText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:10:35.536563",
        "tags": "None",
        "text": " "
    },
    {
        "text_widget_id": 1951847280,
        "index": "5.4",
        "text_widget_class": "CodeViewText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:10:35.876268",
        "tags": "None",
        "text": "s"
    },
    {
        "text_widget_id": 1951847280,
        "index": "5.5",
        "text_widget_class": "CodeViewText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:10:36.005088",
        "tags": "None",
        "text": "e"
    },
    {
        "text_widget_id": 1951847280,
        "index": "5.6",
        "text_widget_class": "CodeViewText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:10:36.180488",
        "tags": "None",
        "text": "r"
    },
    {
        "text_widget_id": 1951847280,
        "index": "5.7",
        "text_widget_class": "CodeViewText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:10:36.372845",
        "tags": "None",
        "text": "v"
    },
    {
        "text_widget_id": 1951847280,
        "index": "5.8",
        "text_widget_class": "CodeViewText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:10:36.486821",
        "tags": "None",
        "text": "o"
    },
    {
        "text_widget_id": 1951847280,
        "index": "5.9",
        "text_widget_class": "CodeViewText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:10:37.407448",
        "tags": "None",
        "text": "("
    },
    {
        "text_widget_id": 1951847280,
        "index": "5.10",
        "text_widget_class": "CodeViewText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:10:37.690283",
        "tags": "None",
        "text": ")"
    },
    {
        "text_widget_id": 1951847280,
        "index": "5.11",
        "text_widget_class": "CodeViewText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:10:38.382675",
        "tags": "None",
        "text": ":"
    },
    {
        "text_widget_id": 1951847280,
        "sequence": "<Button-1>",
        "text_widget_class": "CodeViewText",
        "widget_id": 1951847280,
        "time": "2018-07-19T21:10:40.965757",
        "widget_class": "CodeViewText"
    },
    {
        "index1": "6.0",
        "sequence": "TextDelete",
        "text_widget_class": "CodeViewText",
        "time": "2018-07-19T21:10:42.734210",
        "text_widget_id": 1951847280,
        "index2": "17.0"
    },
    {
        "text_widget_id": 1951847280,
        "index": "6.0",
        "text_widget_class": "CodeViewText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:10:42.743495",
        "tags": "None",
        "text": "    GPIO.setmode(GPIO.BOARD)\n    GPIO.setup(7,GPIO.OUT)\n    try: \n            while True:\n                    GPIO.output(7,1)\n                    time.sleep(0.00015)\n                    GPIO.output(7,0)\n            #time.sleep(1)\n\n    except KeyboardInterrupt:\n            GPIO.cleanup()\n"
    },
    {
        "text_widget_id": 1951847280,
        "sequence": "<Button-1>",
        "text_widget_class": "CodeViewText",
        "widget_id": 1951847280,
        "time": "2018-07-19T21:10:43.670363",
        "widget_class": "CodeViewText"
    },
    {
        "text_widget_id": 1951847280,
        "sequence": "<Button-1>",
        "text_widget_class": "CodeViewText",
        "widget_id": 1951847280,
        "time": "2018-07-19T21:10:45.454790",
        "widget_class": "CodeViewText"
    },
    {
        "text_widget_id": 1951847280,
        "sequence": "<Button-1>",
        "text_widget_class": "CodeViewText",
        "widget_id": 1951847280,
        "time": "2018-07-19T21:10:46.678806",
        "widget_class": "CodeViewText"
    },
    {
        "text_widget_id": 1951847280,
        "sequence": "Save",
        "text_widget_class": "CodeViewText",
        "editor_id": 1951850160,
        "time": "2018-07-19T21:10:47.859999",
        "filename": "/home/pi/functions.py",
        "editor_class": "Editor"
    },
    {
        "sequence": "Command",
        "command_id": "save_file",
        "denied": "False",
        "time": "2018-07-19T21:10:47.866033"
    },
    {
        "sequence": "<Button-1>",
        "widget_class": "Button",
        "widget_id": 1970498704,
        "time": "2018-07-19T21:10:48.704614"
    },
    {
        "sequence": "<Button-1>",
        "widget_class": "Button",
        "widget_id": 1970498704,
        "time": "2018-07-19T21:10:49.167056"
    },
    {
        "index1": "2.4",
        "sequence": "TextDelete",
        "text_widget_class": "ShellText",
        "time": "2018-07-19T21:10:49.263425",
        "text_widget_context": "shell",
        "text_widget_id": 1970495696,
        "index2": "3.0"
    },
    {
        "text_widget_id": 1970495696,
        "index": "2.4",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:10:49.264733",
        "tags": "('automagic', 'toplevel', 'command')",
        "text_widget_context": "shell",
        "text": "%Run functions.py\n"
    },
    {
        "index1": "3.0",
        "sequence": "TextDelete",
        "text_widget_class": "ShellText",
        "time": "2018-07-19T21:10:49.267591",
        "text_widget_context": "shell",
        "text_widget_id": 1970495696,
        "index2": "3.0"
    },
    {
        "sequence": "MagicCommand",
        "cmd_line": "%Run functions.py\n",
        "time": "2018-07-19T21:10:49.268900"
    },
    {
        "text_widget_id": 1970638992,
        "sequence": "Save",
        "text_widget_class": "CodeViewText",
        "editor_id": 1970556176,
        "time": "2018-07-19T21:10:49.269659",
        "filename": "/home/pi/socketserver.py",
        "editor_class": "Editor"
    },
    {
        "command_text": "%Run functions.py\n",
        "sequence": "ShellCommand",
        "time": "2018-07-19T21:10:49.588785"
    },
    {
        "text_widget_id": 1970495696,
        "index": "3.0",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:10:49.644299",
        "tags": "('toplevel', 'prompt')",
        "text_widget_context": "shell",
        "text": ">>> "
    },
    {
        "sequence": "<Button-1>",
        "widget_class": "Button",
        "widget_id": 1970498704,
        "time": "2018-07-19T21:10:52.594142"
    },
    {
        "index1": "3.4",
        "sequence": "TextDelete",
        "text_widget_class": "ShellText",
        "time": "2018-07-19T21:10:52.599216",
        "text_widget_context": "shell",
        "text_widget_id": 1970495696,
        "index2": "4.0"
    },
    {
        "text_widget_id": 1970495696,
        "index": "3.4",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:10:52.601527",
        "tags": "('automagic', 'toplevel', 'command')",
        "text_widget_context": "shell",
        "text": "%Run functions.py\n"
    },
    {
        "index1": "4.0",
        "sequence": "TextDelete",
        "text_widget_class": "ShellText",
        "time": "2018-07-19T21:10:52.606082",
        "text_widget_context": "shell",
        "text_widget_id": 1970495696,
        "index2": "4.0"
    },
    {
        "sequence": "MagicCommand",
        "cmd_line": "%Run functions.py\n",
        "time": "2018-07-19T21:10:52.608346"
    },
    {
        "command_text": "%Run functions.py\n",
        "sequence": "ShellCommand",
        "time": "2018-07-19T21:10:52.952432"
    },
    {
        "text_widget_id": 1970495696,
        "index": "4.0",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:10:53.006061",
        "tags": "('toplevel', 'prompt')",
        "text_widget_context": "shell",
        "text": ">>> "
    },
    {
        "sequence": "<Button-1>",
        "widget_class": "EditorNotebook",
        "widget_id": 1970459376,
        "time": "2018-07-19T21:10:54.526417"
    },
    {
        "sequence": "<Button-1>",
        "widget_class": "Button",
        "widget_id": 1970498704,
        "time": "2018-07-19T21:10:55.557610"
    },
    {
        "index1": "4.4",
        "sequence": "TextDelete",
        "text_widget_class": "ShellText",
        "time": "2018-07-19T21:10:55.665767",
        "text_widget_context": "shell",
        "text_widget_id": 1970495696,
        "index2": "5.0"
    },
    {
        "text_widget_id": 1970495696,
        "index": "4.4",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:10:55.667915",
        "tags": "('automagic', 'toplevel', 'command')",
        "text_widget_context": "shell",
        "text": "%Run socketserver.py\n"
    },
    {
        "index1": "5.0",
        "sequence": "TextDelete",
        "text_widget_class": "ShellText",
        "time": "2018-07-19T21:10:55.672499",
        "text_widget_context": "shell",
        "text_widget_id": 1970495696,
        "index2": "5.0"
    },
    {
        "sequence": "MagicCommand",
        "cmd_line": "%Run socketserver.py\n",
        "time": "2018-07-19T21:10:55.674842"
    },
    {
        "command_text": "%Run socketserver.py\n",
        "sequence": "ShellCommand",
        "time": "2018-07-19T21:10:56.012293"
    },
    {
        "text_widget_id": 1970495696,
        "index": "5.0",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:10:56.068468",
        "tags": "('toplevel', 'error')",
        "text_widget_context": "shell",
        "text": "  "
    },
    {
        "text_widget_id": 1970495696,
        "index": "5.2",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:10:56.069586",
        "tags": "('toplevel', 'error', 'hyperlink')",
        "text_widget_context": "shell",
        "text": "File \"/home/pi/socketserver.py\", line 46"
    },
    {
        "text_widget_id": 1970495696,
        "index": "5.42",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:10:56.070511",
        "tags": "('toplevel', 'error')",
        "text_widget_context": "shell",
        "text": "\n"
    },
    {
        "text_widget_id": 1970495696,
        "index": "6.0",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:10:56.071511",
        "tags": "('toplevel', 'error')",
        "text_widget_context": "shell",
        "text": "    [\ucd9c\ucc98] \uc548\ub4dc\ub85c\uc774\ub4dc \uc2a4\ud29c\ub514\uc624 - \ub77c\uc988\ubca0\ub9ac\ud30c\uc774 \uce74\uba54\ub77c\uc640 UV4L\ub85c \uc2a4\ud2b8\ub9ac\ubc0d \uc571 \ub9cc\ub4e4\uae30(3) : \uc18c\ucf13\ud1b5\uc2e0|\uc791\uc131\uc790 \ucf54\uc2a4\ubaa8\uc2a4\n"
    },
    {
        "text_widget_id": 1970495696,
        "index": "7.0",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:10:56.072626",
        "tags": "('toplevel', 'error')",
        "text_widget_context": "shell",
        "text": "             ^\n"
    },
    {
        "text_widget_id": 1970495696,
        "index": "8.0",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:10:56.073626",
        "tags": "('toplevel', 'error')",
        "text_widget_context": "shell",
        "text": "SyntaxError: invalid syntax\n"
    },
    {
        "text_widget_id": 1970495696,
        "index": "9.0",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:10:56.074544",
        "tags": "('toplevel', 'error')",
        "text_widget_context": "shell",
        "text": "\n"
    },
    {
        "text_widget_id": 1970495696,
        "index": "10.0",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:10:56.075909",
        "tags": "('toplevel', 'prompt')",
        "text_widget_context": "shell",
        "text": ">>> "
    },
    {
        "text_widget_id": 1970638992,
        "sequence": "<Button-1>",
        "text_widget_class": "CodeViewText",
        "widget_id": 1970638992,
        "time": "2018-07-19T21:10:57.495290",
        "widget_class": "CodeViewText"
    },
    {
        "sequence": "<FocusOut>",
        "widget_class": "Workbench",
        "widget_id": 1982950640,
        "time": "2018-07-19T21:11:00.994770"
    },
    {
        "text_widget_id": 1970553296,
        "sequence": "EditorTextCreated",
        "text_widget_class": "CodeViewText",
        "editor_id": 1970667312,
        "time": "2018-07-19T21:11:09.047069",
        "editor_class": "Editor"
    },
    {
        "text_widget_id": 1970553296,
        "sequence": "Open",
        "text_widget_class": "CodeViewText",
        "editor_id": 1970667312,
        "time": "2018-07-19T21:11:09.048029",
        "filename": "/home/pi/servo.py",
        "editor_class": "Editor"
    },
    {
        "index1": "1.0",
        "sequence": "TextDelete",
        "text_widget_class": "CodeViewText",
        "time": "2018-07-19T21:11:09.050485",
        "text_widget_id": 1970553296,
        "index2": "2.0"
    },
    {
        "text_widget_id": 1970553296,
        "index": "1.0",
        "text_widget_class": "CodeViewText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:11:09.059496",
        "tags": "()",
        "text": "import RPi.GPIO as GPIO\nimport time\n\nGPIO.setmode(GPIO.BOARD)\nGPIO.setup(7,GPIO.OUT)\ntry: \n\twhile True:\n\t\tGPIO.output(7,1)\n\t\ttime.sleep(0.00015)\n\t\tGPIO.output(7,0)\n\t#time.sleep(1)\n\nexcept KeyboardInterrupt:\n\tGPIO.cleanup()\n\n\n"
    },
    {
        "sequence": "<FocusIn>",
        "widget_class": "Workbench",
        "widget_id": 1982950640,
        "time": "2018-07-19T21:11:11.317824"
    },
    {
        "sequence": "<Button-1>",
        "widget_class": "Button",
        "widget_id": 1970498704,
        "time": "2018-07-19T21:11:13.147785"
    },
    {
        "index1": "10.4",
        "sequence": "TextDelete",
        "text_widget_class": "ShellText",
        "time": "2018-07-19T21:11:13.207496",
        "text_widget_context": "shell",
        "text_widget_id": 1970495696,
        "index2": "11.0"
    },
    {
        "text_widget_id": 1970495696,
        "index": "10.4",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:11:13.208545",
        "tags": "('automagic', 'toplevel', 'command')",
        "text_widget_context": "shell",
        "text": "%Run servo.py\n"
    },
    {
        "index1": "11.0",
        "sequence": "TextDelete",
        "text_widget_class": "ShellText",
        "time": "2018-07-19T21:11:13.211034",
        "text_widget_context": "shell",
        "text_widget_id": 1970495696,
        "index2": "11.0"
    },
    {
        "sequence": "MagicCommand",
        "cmd_line": "%Run servo.py\n",
        "time": "2018-07-19T21:11:13.212184"
    },
    {
        "command_text": "%Run servo.py\n",
        "sequence": "ShellCommand",
        "time": "2018-07-19T21:11:13.567957"
    },
    {
        "sequence": "<Button-1>",
        "widget_class": "Button",
        "widget_id": 1970499248,
        "time": "2018-07-19T21:11:14.890766"
    },
    {
        "text_widget_id": 1970495696,
        "index": "11.0",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:11:15.023573",
        "tags": "('toplevel', 'prompt')",
        "text_widget_context": "shell",
        "text": ">>> "
    },
    {
        "sequence": "<Button-1>",
        "widget_class": "EditorNotebook",
        "widget_id": 1970459376,
        "time": "2018-07-19T21:11:16.068814"
    },
    {
        "sequence": "<Button-1>",
        "widget_class": "EditorNotebook",
        "widget_id": 1970459376,
        "time": "2018-07-19T21:11:17.226372"
    },
    {
        "text_widget_id": 1970638992,
        "sequence": "<Button-1>",
        "text_widget_class": "CodeViewText",
        "widget_id": 1970638992,
        "time": "2018-07-19T21:11:20.354372",
        "widget_class": "CodeViewText"
    },
    {
        "text_widget_id": 1970638992,
        "sequence": "<Button-1>",
        "text_widget_class": "CodeViewText",
        "widget_id": 1970638992,
        "time": "2018-07-19T21:11:20.553437",
        "widget_class": "CodeViewText"
    },
    {
        "text_widget_id": 1970638992,
        "sequence": "<Button-1>",
        "text_widget_class": "CodeViewText",
        "widget_id": 1970638992,
        "time": "2018-07-19T21:11:21.035251",
        "widget_class": "CodeViewText"
    },
    {
        "text_widget_id": 1970638992,
        "sequence": "<Button-1>",
        "text_widget_class": "CodeViewText",
        "widget_id": 1970638992,
        "time": "2018-07-19T21:11:21.810604",
        "widget_class": "CodeViewText"
    },
    {
        "text_widget_id": 1970638992,
        "sequence": "<Button-1>",
        "text_widget_class": "CodeViewText",
        "widget_id": 1970638992,
        "time": "2018-07-19T21:11:23.057651",
        "widget_class": "CodeViewText"
    },
    {
        "text_widget_id": 1970638992,
        "sequence": "<Button-1>",
        "text_widget_class": "CodeViewText",
        "widget_id": 1970638992,
        "time": "2018-07-19T21:11:24.561663",
        "widget_class": "CodeViewText"
    },
    {
        "text_widget_id": 1970638992,
        "sequence": "<Button-1>",
        "text_widget_class": "CodeViewText",
        "widget_id": 1970638992,
        "time": "2018-07-19T21:11:25.438752",
        "widget_class": "CodeViewText"
    },
    {
        "text_widget_id": 1970638992,
        "index": "2.0",
        "text_widget_class": "CodeViewText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:11:26.250339",
        "tags": "None",
        "text": "i"
    },
    {
        "text_widget_id": 1970638992,
        "index": "2.1",
        "text_widget_class": "CodeViewText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:11:26.485514",
        "tags": "None",
        "text": "m"
    },
    {
        "text_widget_id": 1970638992,
        "index": "2.2",
        "text_widget_class": "CodeViewText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:11:26.698220",
        "tags": "None",
        "text": "p"
    },
    {
        "text_widget_id": 1970638992,
        "index": "2.3",
        "text_widget_class": "CodeViewText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:11:26.880615",
        "tags": "None",
        "text": "o"
    },
    {
        "text_widget_id": 1970638992,
        "index": "2.4",
        "text_widget_class": "CodeViewText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:11:26.918932",
        "tags": "None",
        "text": "r"
    },
    {
        "text_widget_id": 1970638992,
        "index": "2.5",
        "text_widget_class": "CodeViewText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:11:27.095610",
        "tags": "None",
        "text": "t"
    },
    {
        "text_widget_id": 1970638992,
        "index": "2.6",
        "text_widget_class": "CodeViewText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:11:27.209794",
        "tags": "None",
        "text": " "
    },
    {
        "text_widget_id": 1970638992,
        "index": "2.7",
        "text_widget_class": "CodeViewText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:11:27.504651",
        "tags": "None",
        "text": "f"
    },
    {
        "text_widget_id": 1970638992,
        "index": "2.8",
        "text_widget_class": "CodeViewText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:11:27.619462",
        "tags": "None",
        "text": "u"
    },
    {
        "text_widget_id": 1970638992,
        "index": "2.9",
        "text_widget_class": "CodeViewText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:11:28.130070",
        "tags": "None",
        "text": "n"
    },
    {
        "text_widget_id": 1970638992,
        "index": "2.10",
        "text_widget_class": "CodeViewText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:11:28.301083",
        "tags": "None",
        "text": "c"
    },
    {
        "text_widget_id": 1970638992,
        "index": "2.11",
        "text_widget_class": "CodeViewText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:11:28.504761",
        "tags": "None",
        "text": "t"
    },
    {
        "text_widget_id": 1970638992,
        "index": "2.12",
        "text_widget_class": "CodeViewText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:11:28.597126",
        "tags": "None",
        "text": "i"
    },
    {
        "text_widget_id": 1970638992,
        "index": "2.13",
        "text_widget_class": "CodeViewText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:11:28.789397",
        "tags": "None",
        "text": "o"
    },
    {
        "text_widget_id": 1970638992,
        "index": "2.14",
        "text_widget_class": "CodeViewText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:11:29.117864",
        "tags": "None",
        "text": "n"
    },
    {
        "text_widget_id": 1970638992,
        "index": "2.15",
        "text_widget_class": "CodeViewText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:11:29.561417",
        "tags": "None",
        "text": "s"
    },
    {
        "text_widget_id": 1970638992,
        "index": "2.16",
        "text_widget_class": "CodeViewText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:11:29.989322",
        "tags": "None",
        "text": "\n"
    },
    {
        "text_widget_id": 1970638992,
        "index": "3.0",
        "text_widget_class": "CodeViewText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:11:29.998913",
        "tags": "None",
        "text": ""
    },
    {
        "sequence": "<Button-1>",
        "widget_class": "Button",
        "widget_id": 1970498704,
        "time": "2018-07-19T21:11:31.080141"
    },
    {
        "text_widget_id": 1970638992,
        "sequence": "Save",
        "text_widget_class": "CodeViewText",
        "editor_id": 1970556176,
        "time": "2018-07-19T21:11:31.157393",
        "filename": "/home/pi/socketserver.py",
        "editor_class": "Editor"
    },
    {
        "index1": "11.4",
        "sequence": "TextDelete",
        "text_widget_class": "ShellText",
        "time": "2018-07-19T21:11:31.167049",
        "text_widget_context": "shell",
        "text_widget_id": 1970495696,
        "index2": "12.0"
    },
    {
        "text_widget_id": 1970495696,
        "index": "11.4",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:11:31.169850",
        "tags": "('automagic', 'toplevel', 'command')",
        "text_widget_context": "shell",
        "text": "%Run socketserver.py\n"
    },
    {
        "index1": "12.0",
        "sequence": "TextDelete",
        "text_widget_class": "ShellText",
        "time": "2018-07-19T21:11:31.177007",
        "text_widget_context": "shell",
        "text_widget_id": 1970495696,
        "index2": "12.0"
    },
    {
        "sequence": "MagicCommand",
        "cmd_line": "%Run socketserver.py\n",
        "time": "2018-07-19T21:11:31.180030"
    },
    {
        "command_text": "%Run socketserver.py\n",
        "sequence": "ShellCommand",
        "time": "2018-07-19T21:11:31.518839"
    },
    {
        "text_widget_id": 1970495696,
        "index": "12.0",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:11:31.575901",
        "tags": "('toplevel', 'error')",
        "text_widget_context": "shell",
        "text": "  "
    },
    {
        "text_widget_id": 1970495696,
        "index": "12.2",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:11:31.577238",
        "tags": "('toplevel', 'error', 'hyperlink')",
        "text_widget_context": "shell",
        "text": "File \"/home/pi/socketserver.py\", line 47"
    },
    {
        "text_widget_id": 1970495696,
        "index": "12.42",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:11:31.578689",
        "tags": "('toplevel', 'error')",
        "text_widget_context": "shell",
        "text": "\n"
    },
    {
        "text_widget_id": 1970495696,
        "index": "13.0",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:11:31.580210",
        "tags": "('toplevel', 'error')",
        "text_widget_context": "shell",
        "text": "    [\ucd9c\ucc98] \uc548\ub4dc\ub85c\uc774\ub4dc \uc2a4\ud29c\ub514\uc624 - \ub77c\uc988\ubca0\ub9ac\ud30c\uc774 \uce74\uba54\ub77c\uc640 UV4L\ub85c \uc2a4\ud2b8\ub9ac\ubc0d \uc571 \ub9cc\ub4e4\uae30(3) : \uc18c\ucf13\ud1b5\uc2e0|\uc791\uc131\uc790 \ucf54\uc2a4\ubaa8\uc2a4\n"
    },
    {
        "text_widget_id": 1970495696,
        "index": "14.0",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:11:31.581673",
        "tags": "('toplevel', 'error')",
        "text_widget_context": "shell",
        "text": "             ^\n"
    },
    {
        "text_widget_id": 1970495696,
        "index": "15.0",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:11:31.582962",
        "tags": "('toplevel', 'error')",
        "text_widget_context": "shell",
        "text": "SyntaxError: invalid syntax\n"
    },
    {
        "text_widget_id": 1970495696,
        "index": "16.0",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:11:31.584195",
        "tags": "('toplevel', 'error')",
        "text_widget_context": "shell",
        "text": "\n"
    },
    {
        "text_widget_id": 1970495696,
        "index": "17.0",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:11:31.586189",
        "tags": "('toplevel', 'prompt')",
        "text_widget_context": "shell",
        "text": ">>> "
    },
    {
        "sequence": "<FocusOut>",
        "widget_class": "Workbench",
        "widget_id": 1982950640,
        "time": "2018-07-19T21:11:37.195248"
    },
    {
        "sequence": "<FocusIn>",
        "widget_class": "Workbench",
        "widget_id": 1982950640,
        "time": "2018-07-19T21:11:38.062534"
    },
    {
        "text_widget_id": 1970638992,
        "sequence": "<Button-1>",
        "text_widget_class": "CodeViewText",
        "widget_id": 1970638992,
        "time": "2018-07-19T21:11:40.384796",
        "widget_class": "CodeViewText"
    },
    {
        "sequence": "<Button-1>",
        "widget_class": "AutomaticNotebook",
        "widget_id": 1970459248,
        "time": "2018-07-19T21:11:45.286172"
    },
    {
        "text_widget_id": 1970495696,
        "sequence": "<Button-1>",
        "text_widget_class": "ShellText",
        "widget_id": 1970495696,
        "time": "2018-07-19T21:11:46.828315",
        "widget_class": "ShellText",
        "text_widget_context": "shell"
    },
    {
        "text_widget_id": 1970495696,
        "sequence": "<Button-1>",
        "text_widget_class": "ShellText",
        "widget_id": 1970495696,
        "time": "2018-07-19T21:11:50.216217",
        "widget_class": "ShellText",
        "text_widget_context": "shell"
    },
    {
        "text_widget_id": 1970495696,
        "sequence": "<Button-1>",
        "text_widget_class": "ShellText",
        "widget_id": 1970495696,
        "time": "2018-07-19T21:11:51.059935",
        "widget_class": "ShellText",
        "text_widget_context": "shell"
    },
    {
        "text_widget_id": 1970638992,
        "sequence": "<Button-1>",
        "text_widget_class": "CodeViewText",
        "widget_id": 1970638992,
        "time": "2018-07-19T21:11:51.745153",
        "widget_class": "CodeViewText"
    },
    {
        "text_widget_id": 1970638992,
        "sequence": "<Button-1>",
        "text_widget_class": "CodeViewText",
        "widget_id": 1970638992,
        "time": "2018-07-19T21:11:52.087070",
        "widget_class": "CodeViewText"
    },
    {
        "index1": "47.0",
        "sequence": "TextDelete",
        "text_widget_class": "CodeViewText",
        "time": "2018-07-19T21:11:53.778265",
        "text_widget_id": 1970638992,
        "index2": "47.65"
    },
    {
        "index1": "46.9",
        "sequence": "TextDelete",
        "text_widget_class": "CodeViewText",
        "time": "2018-07-19T21:11:54.226398",
        "text_widget_id": 1970638992,
        "index2": "None"
    },
    {
        "text_widget_id": 1970638992,
        "sequence": "<Button-1>",
        "text_widget_class": "CodeViewText",
        "widget_id": 1970638992,
        "time": "2018-07-19T21:11:55.006742",
        "widget_class": "CodeViewText"
    },
    {
        "sequence": "<Button-1>",
        "widget_class": "Button",
        "widget_id": 1970498704,
        "time": "2018-07-19T21:11:55.922099"
    },
    {
        "text_widget_id": 1970638992,
        "sequence": "Save",
        "text_widget_class": "CodeViewText",
        "editor_id": 1970556176,
        "time": "2018-07-19T21:11:56.005773",
        "filename": "/home/pi/socketserver.py",
        "editor_class": "Editor"
    },
    {
        "index1": "17.4",
        "sequence": "TextDelete",
        "text_widget_class": "ShellText",
        "time": "2018-07-19T21:11:56.015153",
        "text_widget_context": "shell",
        "text_widget_id": 1970495696,
        "index2": "18.0"
    },
    {
        "text_widget_id": 1970495696,
        "index": "17.4",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:11:56.016725",
        "tags": "('automagic', 'toplevel', 'command')",
        "text_widget_context": "shell",
        "text": "%Run socketserver.py\n"
    },
    {
        "index1": "18.0",
        "sequence": "TextDelete",
        "text_widget_class": "ShellText",
        "time": "2018-07-19T21:11:56.020113",
        "text_widget_context": "shell",
        "text_widget_id": 1970495696,
        "index2": "18.0"
    },
    {
        "sequence": "MagicCommand",
        "cmd_line": "%Run socketserver.py\n",
        "time": "2018-07-19T21:11:56.021514"
    },
    {
        "command_text": "%Run socketserver.py\n",
        "sequence": "ShellCommand",
        "time": "2018-07-19T21:11:56.326319"
    },
    {
        "text_widget_id": 1970495696,
        "index": "18.0",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:11:56.389301",
        "tags": "('io', 'stdout', 'vertically_spaced')",
        "text_widget_context": "shell",
        "text": "S"
    },
    {
        "text_widget_id": 1970495696,
        "index": "18.1",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:11:56.390824",
        "tags": "('io', 'stdout')",
        "text_widget_context": "shell",
        "text": "ocket created\nSocket bind complete\nSocket now listening\n"
    },
    {
        "sequence": "<Button-1>",
        "widget_class": "Button",
        "widget_id": 1970498704,
        "time": "2018-07-19T21:11:56.489981"
    },
    {
        "text_widget_id": 1970495696,
        "sequence": "<Button-1>",
        "text_widget_class": "ShellText",
        "widget_id": 1970495696,
        "time": "2018-07-19T21:11:57.625190",
        "widget_class": "ShellText",
        "text_widget_context": "shell"
    },
    {
        "sequence": "<Button-1>",
        "widget_class": "Scrollbar",
        "widget_id": 1970664400,
        "time": "2018-07-19T21:11:58.886934"
    },
    {
        "text_widget_id": 1970638992,
        "sequence": "<Button-1>",
        "text_widget_class": "CodeViewText",
        "widget_id": 1970638992,
        "time": "2018-07-19T21:11:59.258859",
        "widget_class": "CodeViewText"
    },
    {
        "text_widget_id": 1970638992,
        "sequence": "<Button-1>",
        "text_widget_class": "CodeViewText",
        "widget_id": 1970638992,
        "time": "2018-07-19T21:12:05.614316",
        "widget_class": "CodeViewText"
    },
    {
        "index1": "18.2",
        "sequence": "TextDelete",
        "text_widget_class": "CodeViewText",
        "time": "2018-07-19T21:12:07.964171",
        "text_widget_id": 1970638992,
        "index2": "18.16"
    },
    {
        "text_widget_id": 1970638992,
        "index": "18.2",
        "text_widget_class": "CodeViewText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:07.974585",
        "tags": "None",
        "text": "$"
    },
    {
        "text_widget_id": 1970495696,
        "index": "21.0",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:08.033051",
        "tags": "('toplevel', 'error')",
        "text_widget_context": "shell",
        "text": "Thonny internal error: Traceback (most recent call last):\n"
    },
    {
        "text_widget_id": 1970495696,
        "index": "22.0",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:08.034471",
        "tags": "('toplevel', 'error')",
        "text_widget_context": "shell",
        "text": "  "
    },
    {
        "text_widget_id": 1970495696,
        "index": "22.2",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:08.036057",
        "tags": "('toplevel', 'error', 'hyperlink')",
        "text_widget_context": "shell",
        "text": "File \"/usr/lib/python3/dist-packages/thonny/shared/thonny/backend.py\", line 588, in execute_source"
    },
    {
        "text_widget_id": 1970495696,
        "index": "22.100",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:08.037680",
        "tags": "('toplevel', 'error')",
        "text_widget_context": "shell",
        "text": "\n"
    },
    {
        "text_widget_id": 1970495696,
        "index": "23.0",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:08.038931",
        "tags": "('toplevel', 'error')",
        "text_widget_context": "shell",
        "text": "    exec(bytecode, global_vars) # <Marker: remove this line from stacktrace>\n"
    },
    {
        "text_widget_id": 1970495696,
        "index": "24.0",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:08.040247",
        "tags": "('toplevel', 'error')",
        "text_widget_context": "shell",
        "text": "  "
    },
    {
        "text_widget_id": 1970495696,
        "index": "24.2",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:08.041689",
        "tags": "('toplevel', 'error', 'hyperlink')",
        "text_widget_context": "shell",
        "text": "File \"/home/pi/socketserver.py\", line 29, in <module>"
    },
    {
        "text_widget_id": 1970495696,
        "index": "24.55",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:08.042720",
        "tags": "('toplevel', 'error')",
        "text_widget_context": "shell",
        "text": "\n"
    },
    {
        "text_widget_id": 1970495696,
        "index": "25.0",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:08.043673",
        "tags": "('toplevel', 'error')",
        "text_widget_context": "shell",
        "text": "    conn, addr = s.accept()\n"
    },
    {
        "text_widget_id": 1970495696,
        "index": "26.0",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:08.045195",
        "tags": "('toplevel', 'error')",
        "text_widget_context": "shell",
        "text": "  "
    },
    {
        "text_widget_id": 1970495696,
        "index": "26.2",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:08.046348",
        "tags": "('toplevel', 'error', 'hyperlink')",
        "text_widget_context": "shell",
        "text": "File \"/usr/lib/python3.5/socket.py\", line 195, in accept"
    },
    {
        "text_widget_id": 1970495696,
        "index": "26.58",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:08.047281",
        "tags": "('toplevel', 'error')",
        "text_widget_context": "shell",
        "text": "\n"
    },
    {
        "text_widget_id": 1970495696,
        "index": "27.0",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:08.048257",
        "tags": "('toplevel', 'error')",
        "text_widget_context": "shell",
        "text": "    fd, addr = self._accept()\n"
    },
    {
        "text_widget_id": 1970495696,
        "index": "28.0",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:08.049223",
        "tags": "('toplevel', 'error')",
        "text_widget_context": "shell",
        "text": "  "
    },
    {
        "text_widget_id": 1970495696,
        "index": "28.2",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:08.050148",
        "tags": "('toplevel', 'error', 'hyperlink')",
        "text_widget_context": "shell",
        "text": "File \"/usr/lib/python3/dist-packages/thonny/shared/thonny/backend.py\", line 133, in signal_handler"
    },
    {
        "text_widget_id": 1970495696,
        "index": "28.100",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:08.051076",
        "tags": "('toplevel', 'error')",
        "text_widget_context": "shell",
        "text": "\n"
    },
    {
        "text_widget_id": 1970495696,
        "index": "29.0",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:08.052763",
        "tags": "('toplevel', 'error')",
        "text_widget_context": "shell",
        "text": "    raise KeyboardInterrupt(\"Execution interrupted\")\n"
    },
    {
        "text_widget_id": 1970495696,
        "index": "30.0",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:08.053817",
        "tags": "('toplevel', 'error')",
        "text_widget_context": "shell",
        "text": "KeyboardInterrupt: Execution interrupted\n"
    },
    {
        "text_widget_id": 1970495696,
        "index": "31.0",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:08.054749",
        "tags": "('toplevel', 'error')",
        "text_widget_context": "shell",
        "text": "\n"
    },
    {
        "text_widget_id": 1970495696,
        "index": "32.0",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:08.055664",
        "tags": "('toplevel', 'error')",
        "text_widget_context": "shell",
        "text": "During handling of the above exception, another exception occurred:\n"
    },
    {
        "text_widget_id": 1970495696,
        "index": "33.0",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:08.056574",
        "tags": "('toplevel', 'error')",
        "text_widget_context": "shell",
        "text": "\n"
    },
    {
        "text_widget_id": 1970495696,
        "index": "34.0",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:08.057489",
        "tags": "('toplevel', 'error')",
        "text_widget_context": "shell",
        "text": "Traceback (most recent call last):\n"
    },
    {
        "text_widget_id": 1970495696,
        "index": "35.0",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:08.058420",
        "tags": "('toplevel', 'error')",
        "text_widget_context": "shell",
        "text": "  "
    },
    {
        "text_widget_id": 1970495696,
        "index": "35.2",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:08.059604",
        "tags": "('toplevel', 'error', 'hyperlink')",
        "text_widget_context": "shell",
        "text": "File \"/usr/lib/python3/dist-packages/thonny/shared/thonny/backend.py\", line 119, in handle_command"
    },
    {
        "text_widget_id": 1970495696,
        "index": "35.100",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:08.061001",
        "tags": "('toplevel', 'error')",
        "text_widget_context": "shell",
        "text": "\n"
    },
    {
        "text_widget_id": 1970495696,
        "index": "36.0",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:08.062149",
        "tags": "('toplevel', 'error')",
        "text_widget_context": "shell",
        "text": "    response = handler(cmd)\n"
    },
    {
        "text_widget_id": 1970495696,
        "index": "37.0",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:08.063165",
        "tags": "('toplevel', 'error')",
        "text_widget_context": "shell",
        "text": "  "
    },
    {
        "text_widget_id": 1970495696,
        "index": "37.2",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:08.064093",
        "tags": "('toplevel', 'error', 'hyperlink')",
        "text_widget_context": "shell",
        "text": "File \"/usr/lib/python3/dist-packages/thonny/shared/thonny/backend.py\", line 155, in _cmd_Run"
    },
    {
        "text_widget_id": 1970495696,
        "index": "37.94",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:08.064992",
        "tags": "('toplevel', 'error')",
        "text_widget_context": "shell",
        "text": "\n"
    },
    {
        "text_widget_id": 1970495696,
        "index": "38.0",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:08.065927",
        "tags": "('toplevel', 'error')",
        "text_widget_context": "shell",
        "text": "    return self._execute_file(cmd, False)\n"
    },
    {
        "text_widget_id": 1970495696,
        "index": "39.0",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:08.066864",
        "tags": "('toplevel', 'error')",
        "text_widget_context": "shell",
        "text": "  "
    },
    {
        "text_widget_id": 1970495696,
        "index": "39.2",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:08.068331",
        "tags": "('toplevel', 'error', 'hyperlink')",
        "text_widget_context": "shell",
        "text": "File \"/usr/lib/python3/dist-packages/thonny/shared/thonny/backend.py\", line 374, in _execute_file"
    },
    {
        "text_widget_id": 1970495696,
        "index": "39.99",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:08.069425",
        "tags": "('toplevel', 'error')",
        "text_widget_context": "shell",
        "text": "\n"
    },
    {
        "text_widget_id": 1970495696,
        "index": "40.0",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:08.070922",
        "tags": "('toplevel', 'error')",
        "text_widget_context": "shell",
        "text": "    result_attributes = self._execute_source_ex(cmd.source, cmd.full_filename, \"exec\", debug_mode)\n"
    },
    {
        "text_widget_id": 1970495696,
        "index": "41.0",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:08.072209",
        "tags": "('toplevel', 'error')",
        "text_widget_context": "shell",
        "text": "  "
    },
    {
        "text_widget_id": 1970495696,
        "index": "41.2",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:08.073201",
        "tags": "('toplevel', 'error', 'hyperlink')",
        "text_widget_context": "shell",
        "text": "File \"/usr/lib/python3/dist-packages/thonny/shared/thonny/backend.py\", line 427, in _execute_source_ex"
    },
    {
        "text_widget_id": 1970495696,
        "index": "41.104",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:08.074118",
        "tags": "('toplevel', 'error')",
        "text_widget_context": "shell",
        "text": "\n"
    },
    {
        "text_widget_id": 1970495696,
        "index": "42.0",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:08.075537",
        "tags": "('toplevel', 'error')",
        "text_widget_context": "shell",
        "text": "    global_vars)\n"
    },
    {
        "text_widget_id": 1970495696,
        "index": "43.0",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:08.076786",
        "tags": "('toplevel', 'error')",
        "text_widget_context": "shell",
        "text": "  "
    },
    {
        "text_widget_id": 1970495696,
        "index": "43.2",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:08.077770",
        "tags": "('toplevel', 'error', 'hyperlink')",
        "text_widget_context": "shell",
        "text": "File \"/usr/lib/python3/dist-packages/thonny/shared/thonny/backend.py\", line 602, in execute_source"
    },
    {
        "text_widget_id": 1970495696,
        "index": "43.100",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:08.078713",
        "tags": "('toplevel', 'error')",
        "text_widget_context": "shell",
        "text": "\n"
    },
    {
        "text_widget_id": 1970495696,
        "index": "44.0",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:08.079685",
        "tags": "('toplevel', 'error')",
        "text_widget_context": "shell",
        "text": "    self._print_user_exception(e_type, e_value, e_traceback)\n"
    },
    {
        "text_widget_id": 1970495696,
        "index": "45.0",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:08.080633",
        "tags": "('toplevel', 'error')",
        "text_widget_context": "shell",
        "text": "  "
    },
    {
        "text_widget_id": 1970495696,
        "index": "45.2",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:08.081623",
        "tags": "('toplevel', 'error', 'hyperlink')",
        "text_widget_context": "shell",
        "text": "File \"/usr/lib/python3/dist-packages/thonny/shared/thonny/backend.py\", line 608, in _print_user_exception"
    },
    {
        "text_widget_id": 1970495696,
        "index": "45.107",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:08.082560",
        "tags": "('toplevel', 'error')",
        "text_widget_context": "shell",
        "text": "\n"
    },
    {
        "text_widget_id": 1970495696,
        "index": "46.0",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:08.084020",
        "tags": "('toplevel', 'error')",
        "text_widget_context": "shell",
        "text": "    lines = traceback.format_exception(e_type, e_value, e_traceback)\n"
    },
    {
        "text_widget_id": 1970495696,
        "index": "47.0",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:08.085191",
        "tags": "('toplevel', 'error')",
        "text_widget_context": "shell",
        "text": "  "
    },
    {
        "text_widget_id": 1970495696,
        "index": "47.2",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:08.086150",
        "tags": "('toplevel', 'error', 'hyperlink')",
        "text_widget_context": "shell",
        "text": "File \"/usr/lib/python3.5/traceback.py\", line 117, in format_exception"
    },
    {
        "text_widget_id": 1970495696,
        "index": "47.71",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:08.087062",
        "tags": "('toplevel', 'error')",
        "text_widget_context": "shell",
        "text": "\n"
    },
    {
        "text_widget_id": 1970495696,
        "index": "48.0",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:08.088026",
        "tags": "('toplevel', 'error')",
        "text_widget_context": "shell",
        "text": "    type(value), value, tb, limit=limit).format(chain=chain))\n"
    },
    {
        "text_widget_id": 1970495696,
        "index": "49.0",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:08.089004",
        "tags": "('toplevel', 'error')",
        "text_widget_context": "shell",
        "text": "  "
    },
    {
        "text_widget_id": 1970495696,
        "index": "49.2",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:08.089919",
        "tags": "('toplevel', 'error', 'hyperlink')",
        "text_widget_context": "shell",
        "text": "File \"/usr/lib/python3.5/traceback.py\", line 474, in __init__"
    },
    {
        "text_widget_id": 1970495696,
        "index": "49.63",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:08.090818",
        "tags": "('toplevel', 'error')",
        "text_widget_context": "shell",
        "text": "\n"
    },
    {
        "text_widget_id": 1970495696,
        "index": "50.0",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:08.091847",
        "tags": "('toplevel', 'error')",
        "text_widget_context": "shell",
        "text": "    capture_locals=capture_locals)\n"
    },
    {
        "text_widget_id": 1970495696,
        "index": "51.0",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:08.092888",
        "tags": "('toplevel', 'error')",
        "text_widget_context": "shell",
        "text": "  "
    },
    {
        "text_widget_id": 1970495696,
        "index": "51.2",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:08.093848",
        "tags": "('toplevel', 'error', 'hyperlink')",
        "text_widget_context": "shell",
        "text": "File \"/usr/lib/python3.5/traceback.py\", line 358, in extract"
    },
    {
        "text_widget_id": 1970495696,
        "index": "51.62",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:08.094756",
        "tags": "('toplevel', 'error')",
        "text_widget_context": "shell",
        "text": "\n"
    },
    {
        "text_widget_id": 1970495696,
        "index": "52.0",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:08.095689",
        "tags": "('toplevel', 'error')",
        "text_widget_context": "shell",
        "text": "    f.line\n"
    },
    {
        "text_widget_id": 1970495696,
        "index": "53.0",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:08.096637",
        "tags": "('toplevel', 'error')",
        "text_widget_context": "shell",
        "text": "  "
    },
    {
        "text_widget_id": 1970495696,
        "index": "53.2",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:08.097546",
        "tags": "('toplevel', 'error', 'hyperlink')",
        "text_widget_context": "shell",
        "text": "File \"/usr/lib/python3.5/traceback.py\", line 282, in line"
    },
    {
        "text_widget_id": 1970495696,
        "index": "53.59",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:08.098465",
        "tags": "('toplevel', 'error')",
        "text_widget_context": "shell",
        "text": "\n"
    },
    {
        "text_widget_id": 1970495696,
        "index": "54.0",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:08.100026",
        "tags": "('toplevel', 'error')",
        "text_widget_context": "shell",
        "text": "    self._line = linecache.getline(self.filename, self.lineno).strip()\n"
    },
    {
        "text_widget_id": 1970495696,
        "index": "55.0",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:08.101193",
        "tags": "('toplevel', 'error')",
        "text_widget_context": "shell",
        "text": "  "
    },
    {
        "text_widget_id": 1970495696,
        "index": "55.2",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:08.102254",
        "tags": "('toplevel', 'error', 'hyperlink')",
        "text_widget_context": "shell",
        "text": "File \"/usr/lib/python3.5/linecache.py\", line 16, in getline"
    },
    {
        "text_widget_id": 1970495696,
        "index": "55.61",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:08.103215",
        "tags": "('toplevel', 'error')",
        "text_widget_context": "shell",
        "text": "\n"
    },
    {
        "text_widget_id": 1970495696,
        "index": "56.0",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:08.104200",
        "tags": "('toplevel', 'error')",
        "text_widget_context": "shell",
        "text": "    lines = getlines(filename, module_globals)\n"
    },
    {
        "text_widget_id": 1970495696,
        "index": "57.0",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:08.105193",
        "tags": "('toplevel', 'error')",
        "text_widget_context": "shell",
        "text": "  "
    },
    {
        "text_widget_id": 1970495696,
        "index": "57.2",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:08.106133",
        "tags": "('toplevel', 'error', 'hyperlink')",
        "text_widget_context": "shell",
        "text": "File \"/usr/lib/python3.5/linecache.py\", line 47, in getlines"
    },
    {
        "text_widget_id": 1970495696,
        "index": "57.62",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:08.107070",
        "tags": "('toplevel', 'error')",
        "text_widget_context": "shell",
        "text": "\n"
    },
    {
        "text_widget_id": 1970495696,
        "index": "58.0",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:08.108054",
        "tags": "('toplevel', 'error')",
        "text_widget_context": "shell",
        "text": "    return updatecache(filename, module_globals)\n"
    },
    {
        "text_widget_id": 1970495696,
        "index": "59.0",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:08.109013",
        "tags": "('toplevel', 'error')",
        "text_widget_context": "shell",
        "text": "  "
    },
    {
        "text_widget_id": 1970495696,
        "index": "59.2",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:08.109929",
        "tags": "('toplevel', 'error', 'hyperlink')",
        "text_widget_context": "shell",
        "text": "File \"/usr/lib/python3.5/linecache.py\", line 136, in updatecache"
    },
    {
        "text_widget_id": 1970495696,
        "index": "59.66",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:08.110843",
        "tags": "('toplevel', 'error')",
        "text_widget_context": "shell",
        "text": "\n"
    },
    {
        "text_widget_id": 1970495696,
        "index": "60.0",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:08.111869",
        "tags": "('toplevel', 'error')",
        "text_widget_context": "shell",
        "text": "    with tokenize.open(fullname) as fp:\n"
    },
    {
        "text_widget_id": 1970495696,
        "index": "61.0",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:08.112924",
        "tags": "('toplevel', 'error')",
        "text_widget_context": "shell",
        "text": "  "
    },
    {
        "text_widget_id": 1970495696,
        "index": "61.2",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:08.114049",
        "tags": "('toplevel', 'error', 'hyperlink')",
        "text_widget_context": "shell",
        "text": "File \"/usr/lib/python3.5/tokenize.py\", line 456, in open"
    },
    {
        "text_widget_id": 1970495696,
        "index": "61.58",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:08.114993",
        "tags": "('toplevel', 'error')",
        "text_widget_context": "shell",
        "text": "\n"
    },
    {
        "text_widget_id": 1970495696,
        "index": "62.0",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:08.115949",
        "tags": "('toplevel', 'error')",
        "text_widget_context": "shell",
        "text": "    encoding, lines = detect_encoding(buffer.readline)\n"
    },
    {
        "text_widget_id": 1970495696,
        "index": "63.0",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:08.116928",
        "tags": "('toplevel', 'error')",
        "text_widget_context": "shell",
        "text": "  "
    },
    {
        "text_widget_id": 1970495696,
        "index": "63.2",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:08.117853",
        "tags": "('toplevel', 'error', 'hyperlink')",
        "text_widget_context": "shell",
        "text": "File \"/usr/lib/python3.5/tokenize.py\", line 425, in detect_encoding"
    },
    {
        "text_widget_id": 1970495696,
        "index": "63.69",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:08.118757",
        "tags": "('toplevel', 'error')",
        "text_widget_context": "shell",
        "text": "\n"
    },
    {
        "text_widget_id": 1970495696,
        "index": "64.0",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:08.119679",
        "tags": "('toplevel', 'error')",
        "text_widget_context": "shell",
        "text": "    first = read_or_stop()\n"
    },
    {
        "text_widget_id": 1970495696,
        "index": "65.0",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:08.120621",
        "tags": "('toplevel', 'error')",
        "text_widget_context": "shell",
        "text": "  "
    },
    {
        "text_widget_id": 1970495696,
        "index": "65.2",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:08.121624",
        "tags": "('toplevel', 'error', 'hyperlink')",
        "text_widget_context": "shell",
        "text": "File \"/usr/lib/python3.5/tokenize.py\", line 383, in read_or_stop"
    },
    {
        "text_widget_id": 1970495696,
        "index": "65.66",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:08.122580",
        "tags": "('toplevel', 'error')",
        "text_widget_context": "shell",
        "text": "\n"
    },
    {
        "text_widget_id": 1970495696,
        "index": "66.0",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:08.123537",
        "tags": "('toplevel', 'error')",
        "text_widget_context": "shell",
        "text": "    return readline()\n"
    },
    {
        "text_widget_id": 1970495696,
        "index": "67.0",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:08.124483",
        "tags": "('toplevel', 'error')",
        "text_widget_context": "shell",
        "text": "  "
    },
    {
        "text_widget_id": 1970495696,
        "index": "67.2",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:08.125892",
        "tags": "('toplevel', 'error', 'hyperlink')",
        "text_widget_context": "shell",
        "text": "File \"/usr/lib/python3/dist-packages/thonny/shared/thonny/backend.py\", line 133, in signal_handler"
    },
    {
        "text_widget_id": 1970495696,
        "index": "67.100",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:08.127026",
        "tags": "('toplevel', 'error')",
        "text_widget_context": "shell",
        "text": "\n"
    },
    {
        "text_widget_id": 1970495696,
        "index": "68.0",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:08.128039",
        "tags": "('toplevel', 'error')",
        "text_widget_context": "shell",
        "text": "    raise KeyboardInterrupt(\"Execution interrupted\")\n"
    },
    {
        "text_widget_id": 1970495696,
        "index": "69.0",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:08.128994",
        "tags": "('toplevel', 'error')",
        "text_widget_context": "shell",
        "text": "KeyboardInterrupt: Execution interrupted\n"
    },
    {
        "text_widget_id": 1970495696,
        "index": "70.0",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:08.129927",
        "tags": "('toplevel', 'error')",
        "text_widget_context": "shell",
        "text": "\n"
    },
    {
        "text_widget_id": 1970495696,
        "index": "71.0",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:08.131349",
        "tags": "('toplevel', 'prompt')",
        "text_widget_context": "shell",
        "text": ">>> "
    },
    {
        "index1": "18.2",
        "sequence": "TextDelete",
        "text_widget_class": "CodeViewText",
        "time": "2018-07-19T21:12:09.127983",
        "text_widget_id": 1970638992,
        "index2": "None"
    },
    {
        "text_widget_id": 1970638992,
        "sequence": "<Button-1>",
        "text_widget_class": "CodeViewText",
        "widget_id": 1970638992,
        "time": "2018-07-19T21:12:12.057003",
        "widget_class": "CodeViewText"
    },
    {
        "text_widget_id": 1970495696,
        "sequence": "<Button-1>",
        "text_widget_class": "ShellText",
        "widget_id": 1970495696,
        "time": "2018-07-19T21:12:12.554526",
        "widget_class": "ShellText",
        "text_widget_context": "shell"
    },
    {
        "text_widget_id": 1926728112,
        "sequence": "EditorTextCreated",
        "text_widget_class": "CodeViewText",
        "editor_id": 1926726864,
        "time": "2018-07-19T21:12:12.659410",
        "editor_class": "Editor"
    },
    {
        "text_widget_id": 1926728112,
        "sequence": "Open",
        "text_widget_class": "CodeViewText",
        "editor_id": 1926726864,
        "time": "2018-07-19T21:12:12.662206",
        "filename": "/usr/lib/python3/dist-packages/thonny/shared/thonny/backend.py",
        "editor_class": "Editor"
    },
    {
        "index1": "1.0",
        "sequence": "TextDelete",
        "text_widget_class": "CodeViewText",
        "time": "2018-07-19T21:12:12.666751",
        "text_widget_id": 1926728112,
        "index2": "2.0"
    },
    {
        "text_widget_id": 1926728112,
        "index": "1.0",
        "text_widget_class": "CodeViewText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:12.725794",
        "tags": "()",
        "text": "# -*- coding: utf-8 -*-\n\nimport sys \nimport os.path\nimport inspect\nimport ast\nimport _ast\nimport _io\nimport traceback\nimport types\nimport logging\nimport pydoc\nimport builtins\nimport site\n\nimport __main__  # @UnresolvedImport\n\nfrom thonny import ast_utils\nfrom thonny.common import TextRange,\\\n    parse_message, serialize_message, DebuggerCommand,\\\n    ToplevelCommand, FrameInfo, InlineCommand, InputSubmission\nimport signal\nimport warnings\n\nBEFORE_STATEMENT_MARKER = \"_thonny_hidden_before_stmt\"\nBEFORE_EXPRESSION_MARKER = \"_thonny_hidden_before_expr\"\nAFTER_STATEMENT_MARKER = \"_thonny_hidden_after_stmt\"\nAFTER_EXPRESSION_MARKER = \"_thonny_hidden_after_expr\"\n\nEXCEPTION_TRACEBACK_LIMIT = 100\nDEBUG = True    \n\nlogger = logging.getLogger()\ninfo = logger.info\n\nclass VM:\n    def __init__(self):\n        self._main_dir = os.path.dirname(sys.modules[\"thonny\"].__file__)\n        self._heap = {} # WeakValueDictionary would be better, but can't store reference to None\n        site.sethelper() # otherwise help function is not available\n        pydoc.pager = pydoc.plainpager # otherwise help command plays tricks\n        self._install_fake_streams()\n        self._current_executor = None\n        self._io_level = 0\n        \n        original_argv = sys.argv.copy()\n        original_path = sys.path.copy()\n        \n        # clean up path\n        sys.path = [d for d in sys.path if d != \"\"]\n        \n        # script mode\n        if len(sys.argv) > 1:\n            special_names_to_remove = set()\n            sys.argv[:] = sys.argv[1:] # shift argv[1] to position of script name\n            sys.path.insert(0, os.path.abspath(os.path.dirname(sys.argv[0]))) # add program's dir\n            __main__.__dict__[\"__file__\"] = sys.argv[0]\n            # TODO: inspect.getdoc\n        \n        # shell mode\n        else:\n            special_names_to_remove = {\"__file__\", \"__cached__\"}\n            sys.argv[:] = [\"\"] # empty \"script name\"\n            sys.path.insert(0, \"\")   # current dir\n        \n        # add jedi\n        if \"JEDI_LOCATION\" in os.environ:\n            sys.path.append(os.environ[\"JEDI_LOCATION\"])\n    \n        # clean __main__ global scope\n        for key in list(__main__.__dict__.keys()):\n            if not key.startswith(\"__\") or key in special_names_to_remove:\n                del __main__.__dict__[key] \n        \n        # unset __doc__, then exec dares to write doc of the script there\n        __main__.__doc__ = None\n        \n        self.send_message(self.create_message(\"ToplevelResult\",\n                          main_dir=self._main_dir,\n                          original_argv=original_argv,\n                          original_path=original_path,\n                          argv=sys.argv,\n                          path=sys.path,\n                          welcome_text=\"Python \" + _get_python_version_string(),\n                          executable=sys.executable,\n                          in_venv=hasattr(sys, 'base_prefix') and sys.base_prefix != sys.prefix,\n                          python_version=_get_python_version_string(),\n                          cwd=os.getcwd()))\n        \n        self._install_signal_handler()\n        \n    def mainloop(self):\n        try:\n            while True: \n                try:\n                    cmd = self._fetch_command()\n                    self.handle_command(cmd, \"waiting_toplevel_command\")\n                except KeyboardInterrupt:\n                    logger.exception(\"Interrupt in mainloop\")\n                    # Interrupt must always result in waiting_toplevel_command state\n                    # Don't show error messages, as the interrupted command may have been InlineCommand\n                    # (handlers of ToplevelCommands in normal cases catch the interrupt and provide\n                    # relevant message)  \n                    self.send_message(self.create_message(\"ToplevelResult\"))\n        except:\n            logger.exception(\"Crash in mainloop\")\n            \n            \n    def handle_command(self, cmd, command_context):\n        assert isinstance(cmd, ToplevelCommand) or isinstance(cmd, InlineCommand)\n        \n        error_response_type = \"ToplevelResult\" if isinstance(cmd, ToplevelCommand) else \"InlineError\"\n        try:\n            handler = getattr(self, \"_cmd_\" + cmd.command)\n        except AttributeError:\n            response = self.create_message(error_response_type, error=\"Unknown command: \" + cmd.command)\n        else:\n            try:\n                response = handler(cmd)\n            except:\n                response = self.create_message(error_response_type,\n                    error=\"Thonny internal error: {0}\".format(traceback.format_exc(EXCEPTION_TRACEBACK_LIMIT)))\n        \n        if response is not None:\n            response[\"command_context\"] = command_context\n            response[\"command\"] = cmd.command\n            if response[\"message_type\"] == \"ToplevelResult\":\n                self._add_tkinter_info(response)\n            self.send_message(response)\n    \n    def _install_signal_handler(self):\n        def signal_handler(signal, frame):\n            raise KeyboardInterrupt(\"Execution interrupted\")\n        \n        if os.name == 'nt':\n            signal.signal(signal.SIGBREAK, signal_handler)\n        else:\n            signal.signal(signal.SIGINT, signal_handler)        \n    \n    def _cmd_cd(self, cmd):\n        try:\n            os.chdir(cmd.path)\n            return self.create_message(\"ToplevelResult\")\n        except Exception as e:\n            # TODO: should output user error\n            return self.create_message(\"ToplevelResult\", error=str(e))\n    \n    def _cmd_Reset(self, cmd):\n        # nothing to do, because Reset always happens in fresh process\n        return self.create_message(\"ToplevelResult\",\n                                   welcome_text=\"Python \" + _get_python_version_string(),\n                                   executable=sys.executable)\n    \n    def _cmd_Run(self, cmd):\n        return self._execute_file(cmd, False)\n    \n    def _cmd_run(self, cmd):\n        return self._execute_file(cmd, False)\n    \n    def _cmd_Debug(self, cmd):\n        return self._execute_file(cmd, True)\n    \n    def _cmd_debug(self, cmd):\n        return self._execute_file(cmd, True)\n    \n    def _cmd_execute_source(self, cmd):\n        return self._execute_source(cmd, \"ToplevelResult\")\n    \n    def _cmd_execute_source_inline(self, cmd):\n        return self._execute_source(cmd, \"InlineResult\")\n    \n    def _cmd_tkupdate(self, cmd):\n        # advance the event loop\n        # http://bugs.python.org/issue989712\n        # http://bugs.python.org/file6090/run.py.diff\n        try:\n            root = self._get_tkinter_default_root()\n            if root is None:\n                return\n            \n            import tkinter\n            while root.dooneevent(tkinter._tkinter.DONT_WAIT):\n                pass\n                 \n        except:\n            pass\n            \n        return None\n    \n    \n    def _cmd_get_globals(self, cmd):\n        if not cmd.module_name in sys.modules:\n            raise ThonnyClientError(\"Module '{0}' is not loaded\".format(cmd.module_name))\n        \n        return self.create_message(\"Globals\", module_name=cmd.module_name,\n                              globals=self.export_variables(sys.modules[cmd.module_name].__dict__))\n    \n    def _cmd_get_locals(self, cmd):\n        for frame in inspect.stack():\n            if id(frame) == cmd.frame_id:\n                return self.create_message(\"Locals\", locals=self.export_variables(frame.f_locals))\n        else:\n            raise ThonnyClientError(\"Frame '{0}' not found\".format(cmd.frame_id))\n            \n    \n    def _cmd_get_heap(self, cmd):\n        result = {}\n        for key in self._heap:\n            result[key] = self.export_value(self._heap[key])\n            \n        return self.create_message(\"Heap\", heap=result)\n    \n    def _cmd_shell_autocomplete(self, cmd):\n        error = None\n        try:\n            import jedi\n        except ImportError:\n            completions = []\n            error = \"Could not import jedi\"\n        else:\n            try:\n                #with warnings.catch_warnings():\n                interpreter = jedi.Interpreter(cmd.source, [__main__.__dict__])\n                completions = self._export_completions(interpreter.completions())\n            except Exception as e:\n                completions = []\n                error = \"Autocomplete error: \" + str(e)\n            except:\n                completions = []\n                error = \"Autocomplete error\"\n        \n        return self.create_message(\"ShellCompletions\", \n            source=cmd.source,\n            completions=completions,\n            error=error\n        )\n    \n    def _cmd_editor_autocomplete(self, cmd):\n        error = None\n        try:\n            import jedi\n            with warnings.catch_warnings():\n                script = jedi.Script(cmd.source, cmd.row, cmd.column, cmd.filename)\n                completions = self._export_completions(script.completions())\n                \n        except ImportError:\n            completions = []\n            error = \"Could not import jedi\"\n        except Exception as e:\n            completions = []\n            error = \"Autocomplete error: \" + str(e)\n        except:\n            completions = []\n            error = \"Autocomplete error\"\n        \n        return self.create_message(\"EditorCompletions\", \n                          source=cmd.source,\n                          row=cmd.row,\n                          column=cmd.column,\n                          filename=cmd.filename,\n                          completions=completions,\n                          error=error)\n    \n    def _export_completions(self, jedi_completions):\n        result = []\n        for c in jedi_completions:\n            if not c.name.startswith(\"__\"):\n                record = {\"name\":c.name, \"complete\":c.complete, \n                          \"type\":c.type, \"description\":c.description}\n                try:\n                    \"\"\" TODO: \n                    if c.type in [\"class\", \"module\", \"function\"]:\n                        if c.type == \"function\":\n                            record[\"docstring\"] = c.docstring()\n                        else:\n                            record[\"docstring\"] = c.description + \"\\n\" + c.docstring()\n                    \"\"\"\n                except:\n                    pass\n                result.append(record)\n        return result\n        \n    \n    def _cmd_get_object_info(self, cmd):\n        if cmd.object_id in self._heap:\n            value = self._heap[cmd.object_id]\n            attributes = {}\n            for name in dir(value):\n                if not name.startswith(\"__\") or cmd.all_attributes:\n                    #attributes[name] = inspect.getattr_static(value, name)\n                    try: \n                        attributes[name] = getattr(value, name)\n                    except:\n                        pass \n            \n            self._heap[id(type(value))] = type(value)\n            \n            info = {'id' : cmd.object_id,\n                    'repr' : repr(value),\n                    'type' : str(type(value)),\n                    'type_id' : id(type(value)),\n                    'attributes': self.export_variables(attributes)}\n            \n            if isinstance(value, _io.TextIOWrapper):\n                self._add_file_handler_info(value, info)\n            elif (type(value) in (types.BuiltinFunctionType, types.BuiltinMethodType,\n                                 types.FunctionType, types.LambdaType, types.MethodType)):\n                self._add_function_info(value, info)\n            elif (isinstance(value, list) \n                  or isinstance(value, tuple)\n                  or isinstance(value, set)):\n                self._add_elements_info(value, info)\n            elif (isinstance(value, dict)):\n                self._add_entries_info(value, info)\n            \n        else:\n            info = {'id' : cmd.object_id,\n                    \"repr\": \"<object info not found>\",\n                    \"type\" : \"object\",\n                    \"type_id\" : id(object),\n                    \"attributes\" : {}}\n        \n        return self.create_message(\"ObjectInfo\", id=cmd.object_id, info=info)\n    \n    def _get_tkinter_default_root(self):\n        tkinter = sys.modules.get(\"tkinter\")\n        if tkinter is not None:\n            return getattr(tkinter, \"_default_root\", None)\n        else:\n            return None\n\n    \n    def _add_file_handler_info(self, value, info):\n        try:\n            assert isinstance(value.name, str)\n            assert value.mode in (\"r\", \"rt\", \"tr\", \"br\", \"rb\")\n            assert value.errors in (\"strict\", None)\n            assert value.newlines is None or value.tell() > 0\n            # TODO: cache the content\n            # TODO: don't read too big files\n            with open(value.name, encoding=value.encoding) as f:\n                info[\"file_encoding\"] = f.encoding\n                info[\"file_content\"] = f.read()\n                info[\"file_tell\"] = value.tell()\n        except Exception as e:\n            info[\"file_error\"] = \"Could not get file content, error:\" + str(e)\n            pass\n    \n    def _add_tkinter_info(self, msg):\n        # tkinter._default_root is not None,\n        # when window has been created and mainloop isn't called or hasn't ended yet\n        msg[\"tkinter_is_active\"] = self._get_tkinter_default_root() is not None\n    \n    def _add_function_info(self, value, info):\n        try:\n            info[\"source\"] = inspect.getsource(value)\n        except:\n            pass\n        \n    def _add_elements_info(self, value, info):\n        info[\"elements\"] = []\n        for element in value:\n            info[\"elements\"].append(self.export_value(element))\n        \n    def _add_entries_info(self, value, info):\n        info[\"entries\"] = []\n        for key in value:\n            info[\"entries\"].append((self.export_value(key),\n                                     self.export_value(value[key])))\n        \n    def _execute_file(self, cmd, debug_mode):\n        # args are accepted only in Run and Debug,\n        # and were stored in sys.argv already in VM.__init__\n        result_attributes = self._execute_source_ex(cmd.source, cmd.full_filename, \"exec\", debug_mode) \n        return self.create_message(\"ToplevelResult\", **result_attributes)\n    \n    def _execute_source(self, cmd, result_type):\n        filename = \"<pyshell>\"\n        \n        if hasattr(cmd, \"global_vars\"):\n            global_vars = cmd.global_vars\n        elif hasattr(cmd, \"extra_vars\"):\n            global_vars = __main__.__dict__.copy() # Don't want to mess with main namespace\n            global_vars.update(cmd.extra_vars)\n        else:\n            global_vars = __main__.__dict__\n\n        # let's see if it's single expression or something more complex\n        try:\n            root = ast.parse(cmd.source, filename=filename, mode=\"exec\")\n        except SyntaxError as e:\n            return self.create_message(result_type,\n                error=\"\".join(traceback.format_exception_only(SyntaxError, e)))\n            \n        assert isinstance(root, ast.Module)\n            \n        if len(root.body) == 1 and isinstance(root.body[0], ast.Expr):\n            mode = \"eval\"\n        else:\n            mode = \"exec\"\n            \n        result_attributes = self._execute_source_ex(cmd.source, filename, mode,\n            hasattr(cmd, \"debug_mode\") and cmd.debug_mode,\n            global_vars)\n        \n        if \"__result__\" in global_vars:\n            result_attributes[\"__result__\"] = global_vars[\"__result__\"]\n        \n        if hasattr(cmd, \"request_id\"):\n            result_attributes[\"request_id\"] = cmd.request_id\n        else:\n            result_attributes[\"request_id\"] = None\n        \n        return self.create_message(result_type, **result_attributes)\n        \n    def _execute_source_ex(self, source, filename, execution_mode, debug_mode,\n                        global_vars=None):\n        if debug_mode:\n            self._current_executor = FancyTracer(self)\n        else:\n            self._current_executor = Executor(self)\n        \n        try:\n            return self._current_executor.execute_source(source, \n                                                         filename,\n                                                         execution_mode,\n                                                         global_vars)\n        finally:\n            self._current_executor = None\n    \n        \n    def _install_fake_streams(self):\n        self._original_stdin = sys.stdin\n        self._original_stdout = sys.stdout\n        self._original_stderr = sys.stderr        \n        \n        # yes, both out and err will be directed to out (but with different tags)\n        # this allows client to see the order of interleaving writes to stdout/stderr\n        sys.stdin = VM.FakeInputStream(self, sys.stdin)\n        sys.stdout = VM.FakeOutputStream(self, sys.stdout, \"stdout\")\n        sys.stderr = VM.FakeOutputStream(self, sys.stdout, \"stderr\") \n             \n        # fake it properly: replace also \"backup\" streams\n        sys.__stdin__ = sys.stdin\n        sys.__stdout__ = sys.stdout\n        sys.__stderr__ = sys.stderr\n        \n    def _fetch_command(self):\n        line = self._original_stdin.readline()\n        if line == \"\":\n            logger.info(\"Read stdin EOF\")\n            sys.exit()\n        cmd = parse_message(line)\n        return cmd\n\n    def create_message(self, message_type, **kwargs):\n        kwargs[\"message_type\"] = message_type\n        if \"cwd\" not in kwargs:\n            kwargs[\"cwd\"] = os.getcwd()\n            \n        return kwargs\n\n    def send_message(self, msg):\n        self._original_stdout.write(serialize_message(msg) + \"\\n\")\n        self._original_stdout.flush()\n        \n    def export_value(self, value, skip_None=False):\n        if value is None and skip_None:\n            return None\n        \n        self._heap[id(value)] = value\n        try:\n            type_name = value.__class__.__name__\n        except:\n            type_name = type(value).__name__ \n            \n        result = {'id' : id(value),\n                  'repr' : repr(value), \n                  'type_name'  : type_name}\n        \n        return result\n    \n    def export_variables(self, variables):\n        result = {}\n        for name in variables:\n            if not name.startswith(\"_thonny_hidden_\"):\n                result[name] = self.export_value(variables[name])\n            \n        return result\n           \n    def _debug(self, *args):\n        print(\"VM:\", *args, file=self._original_stderr)\n    \n    \n    def _enter_io_function(self):\n        self._io_level += 1\n    \n    def _exit_io_function(self):\n        self._io_level -= 1\n    \n    def is_doing_io(self):\n        return self._io_level > 0\n    \n\n    class FakeStream:\n        def __init__(self, vm, target_stream):\n            self._vm = vm\n            self._target_stream = target_stream\n            \n        def isatty(self):\n            return True\n        \n        def __getattr__(self, name):\n            # TODO: is it safe to perform those other functions without notifying vm\n            # via _enter_io_function?\n            return getattr(self._target_stream, name)\n        \n    class FakeOutputStream(FakeStream):\n        def __init__(self, vm, target_stream, stream_name):\n            VM.FakeStream.__init__(self, vm, target_stream)\n            self._stream_name = stream_name\n            \n        def write(self, data):\n            try:\n                self._vm._enter_io_function()\n                if data != \"\":\n                    self._vm.send_message(self._vm.create_message(\"ProgramOutput\", stream_name=self._stream_name, data=data))\n            finally:\n                self._vm._exit_io_function()\n        \n        def writelines(self, lines):\n            try:\n                self._vm._enter_io_function()\n                self.write(''.join(lines))\n            finally:\n                self._vm._exit_io_function()\n    \n    class FakeInputStream(FakeStream):\n        \n        def _generic_read(self, method, limit=-1):\n            try:\n                self._vm._enter_io_function()\n                self._vm.send_message(self._vm.create_message(\"InputRequest\", method=method, limit=limit))\n                \n                while True:\n                    cmd = self._vm._fetch_command()\n                    if isinstance(cmd, InputSubmission):\n                        return cmd.data\n                    elif isinstance(cmd, InlineCommand):\n                        self._vm.handle_command(cmd, \"waiting_input\")\n                    else:\n                        raise ThonnyClientError(\"Wrong type of command when waiting for input\")\n            finally:\n                self._vm._exit_io_function()\n        \n        def read(self, limit=-1):\n            return self._generic_read(\"read\", limit)\n        \n        def readline(self, limit=-1):\n            return self._generic_read(\"readline\", limit)\n        \n        def readlines(self, limit=-1):\n            return self._generic_read(\"readlines\", limit)\n            \n    \n\n\nclass Executor:\n    def __init__(self, vm):\n        self._vm = vm\n    \n    def execute_source(self, source, filename, mode, global_vars=None):\n        \n        if global_vars is None:\n            global_vars = __main__.__dict__\n        \n        try:\n            bytecode = self._compile_source(source, filename, mode)\n            if hasattr(self, \"_trace\"):\n                sys.settrace(self._trace)    \n            if mode == \"eval\":\n                value = eval(bytecode, global_vars)\n                if value is not None:\n                    builtins._ = value \n                return {\"value_info\" : self._vm.export_value(value)}\n            else:\n                assert mode == \"exec\"\n                exec(bytecode, global_vars) # <Marker: remove this line from stacktrace>\n                return {\"context_info\" : \"after normal execution\", \"source\" : source, \"filename\" : filename, \"mode\" : mode}\n        except SyntaxError as e:\n            return {\"error\" : \"\".join(traceback.format_exception_only(SyntaxError, e))}\n        except ThonnyClientError as e:\n            return {\"error\" : str(e)}\n        except SystemExit:\n            e_type, e_value, e_traceback = sys.exc_info()\n            self._print_user_exception(e_type, e_value, e_traceback)\n            return {\"SystemExit\" : True}\n        except:\n            # other unhandled exceptions (supposedly client program errors) are printed to stderr, as usual\n            # for VM mainloop they are not exceptions\n            e_type, e_value, e_traceback = sys.exc_info()\n            self._print_user_exception(e_type, e_value, e_traceback)\n            return {\"context_info\" : \"other unhandled exception\"}\n        finally:\n            sys.settrace(None)\n    \n    def _print_user_exception(self, e_type, e_value, e_traceback):\n        lines = traceback.format_exception(e_type, e_value, e_traceback)\n\n        for line in lines:\n            # skip lines denoting thonny execution frame\n            if (\"thonny/backend\" in line \n                or \"thonny\\\\backend\" in line\n                or \"remove this line from stacktrace\" in line):\n                continue\n            else:\n                sys.stderr.write(line)\n\n    def _compile_source(self, source, filename, mode):\n        return compile(source, filename, mode)\n\n\nclass FancyTracer(Executor):\n    \n    def __init__(self, vm):\n        self._vm = vm\n        self._normcase_thonny_src_dir = os.path.normcase(os.path.dirname(sys.modules[\"thonny\"].__file__)) \n        self._instrumented_files = _PathSet()\n        self._interesting_files = _PathSet() # only events happening in these files are reported\n        self._current_command = None\n        self._unhandled_exception = None\n        self._install_marker_functions()\n        self._custom_stack = []\n    \n    def execute_source(self, source, filename, mode, global_vars=None):\n        self._current_command = DebuggerCommand(command=\"step\", state=None, focus=None, frame_id=None, exception=None)\n        \n        return Executor.execute_source(self, source, filename, mode, global_vars)\n        #assert len(self._custom_stack) == 0\n        \n    def _install_marker_functions(self):\n        # Make dummy marker functions universally available by putting them\n        # into builtin scope        \n        self.marker_function_names = {\n            BEFORE_STATEMENT_MARKER,\n            AFTER_STATEMENT_MARKER, \n            BEFORE_EXPRESSION_MARKER,\n            AFTER_EXPRESSION_MARKER,\n        }\n        \n        for name in self.marker_function_names:\n            if not hasattr(builtins, name):\n                setattr(builtins, name, getattr(self, name))\n        \n    def _is_interesting_exception(self, frame):\n        # interested only in exceptions in command frame or it's parent frames\n        cmd = self._current_command\n        return (id(frame) == cmd.frame_id\n                or not self._frame_is_alive(cmd.frame_id))\n\n    def _compile_source(self, source, filename, mode):\n        root = ast.parse(source, filename, mode)\n        \n        ast_utils.mark_text_ranges(root, source)\n        self._tag_nodes(root)        \n        self._insert_expression_markers(root)\n        self._insert_statement_markers(root)\n        self._instrumented_files.add(filename)\n        \n        return compile(root, filename, mode)\n    \n    def _may_step_in(self, code):\n            \n        return not (\n            code is None \n            or code.co_filename is None\n            or code.co_flags & inspect.CO_GENERATOR  # @UndefinedVariable\n            or sys.version_info >= (3,5) and code.co_flags & inspect.CO_COROUTINE  # @UndefinedVariable\n            or sys.version_info >= (3,5) and code.co_flags & inspect.CO_ITERABLE_COROUTINE  # @UndefinedVariable\n            or sys.version_info >= (3,6) and code.co_flags & inspect.CO_ASYNC_GENERATOR  # @UndefinedVariable\n            or \"importlib._bootstrap\" in code.co_filename\n            or os.path.normcase(code.co_filename) not in self._instrumented_files \n                and code.co_name not in self.marker_function_names\n            or os.path.normcase(code.co_filename).startswith(self._normcase_thonny_src_dir)\n                and code.co_name not in self.marker_function_names\n            or self._vm.is_doing_io() \n        )\n        \n    \n    def _trace(self, frame, event, arg):\n        \"\"\"\n        1) Detects marker calls and responds to client queries in these spots\n        2) Maintains a customized view of stack\n        \"\"\"\n        if not self._may_step_in(frame.f_code):\n            return\n        \n        code_name = frame.f_code.co_name\n        \n        if event == \"call\":\n            self._unhandled_exception = None # some code is running, therefore exception is not propagating anymore\n            \n            if code_name in self.marker_function_names:\n                # the main thing\n                if code_name == BEFORE_STATEMENT_MARKER:\n                    event = \"before_statement\"\n                elif code_name == AFTER_STATEMENT_MARKER:\n                    event = \"after_statement\"\n                elif code_name == BEFORE_EXPRESSION_MARKER:\n                    event = \"before_expression\"\n                elif code_name == AFTER_EXPRESSION_MARKER:\n                    event = \"after_expression\"\n                else:\n                    raise AssertionError(\"Unknown marker function\")\n                \n                marker_function_args = frame.f_locals.copy()\n                del marker_function_args[\"self\"]\n                \n                self._handle_progress_event(frame.f_back, event, marker_function_args)\n                self._try_interpret_as_again_event(frame.f_back, event, marker_function_args)\n                \n                \n            else:\n                # Calls to proper functions.\n                # Client doesn't care about these events,\n                # it cares about \"before_statement\" events in the first statement of the body\n                self._custom_stack.append(CustomStackFrame(frame, \"call\"))\n        \n        elif event == \"return\":\n            if code_name not in self.marker_function_names:\n                self._custom_stack.pop()\n                if len(self._custom_stack) == 0:\n                    # We popped last frame, this means our program has ended.\n                    # There may be more events coming from upper (system) frames\n                    # but we're not interested in those\n                    sys.settrace(None)\n            else:\n                pass\n                \n        elif event == \"exception\":\n            exc = arg[1]\n            if self._unhandled_exception is None:\n                # this means it's the first time we see this exception\n                exc.causing_frame = frame\n            else:\n                # this means the exception is propagating to older frames\n                # get the causing_frame from previous occurrence\n                exc.causing_frame = self._unhandled_exception.causing_frame \n            \n            self._unhandled_exception = exc\n            if self._is_interesting_exception(frame):\n                self._report_state_and_fetch_next_message(frame)\n\n        # TODO: support line event in non-instrumented files\n        elif event == \"line\":\n            self._unhandled_exception = None  \n                \n        return self._trace\n        \n            \n    def _handle_progress_event(self, frame, event, args):\n        \"\"\"\n        Tries to respond to current command in this state. \n        If it can't, then it returns, program resumes\n        and _trace will call it again in another state.\n        Otherwise sends response and fetches next command.  \n        \"\"\"\n        self._debug(\"Progress event:\", event, self._current_command)\n        focus = TextRange(*args[\"text_range\"])\n        \n        self._custom_stack[-1].last_event = event\n        self._custom_stack[-1].last_event_focus = focus\n        self._custom_stack[-1].last_event_args = args\n        \n        # Select the correct method according to the command\n        tester = getattr(self, \"_cmd_\" + self._current_command.command + \"_completed\")\n             \n        # If method decides we're in the right place to respond to the command ...\n        if tester(frame, event, args, focus, self._current_command):\n            if event == \"after_expression\":\n                value = self._vm.export_value(args[\"value\"])\n            else:\n                value = None\n            self._report_state_and_fetch_next_message(frame, value)\n    \n    def _report_state_and_fetch_next_message(self, frame, value=None):\n            #self._debug(\"Completed command: \", self._current_command)\n            \n            if self._unhandled_exception is not None:\n                frame_infos = traceback.format_stack(self._unhandled_exception.causing_frame)\n                # I want to show frames from current frame to causing_frame\n                if frame == self._unhandled_exception.causing_frame:\n                    interesting_frame_infos = []\n                else:\n                    # c how far is current frame from causing_frame?\n                    _distance = 0\n                    _f = self._unhandled_exception.causing_frame \n                    while _f != frame:\n                        _distance += 1\n                        _f = _f.f_back\n                        if _f == None:\n                            break\n                    interesting_frame_infos = frame_infos[-_distance:]\n                exception_lower_stack_description = \"\".join(interesting_frame_infos)\n                exception_msg = str(self._unhandled_exception)\n            else:\n                exception_lower_stack_description = None \n                exception_msg = None\n            \n            self._vm.send_message(self._vm.create_message(\"DebuggerProgress\",\n                command=self._current_command.command,\n                stack=self._export_stack(),\n                exception=self._vm.export_value(self._unhandled_exception, True),\n                exception_msg=exception_msg,\n                exception_lower_stack_description=exception_lower_stack_description,\n                value=value,\n                command_context=\"waiting_debugger_command\"\n            ))\n            \n            # Fetch next debugger command\n            self._current_command = self._vm._fetch_command()\n            self._debug(\"got command:\", self._current_command)\n            # get non-progress commands out our way\n            self._respond_to_inline_commands()  \n            assert isinstance(self._current_command, DebuggerCommand)\n            \n        # Return and let Python run to next progress event\n        \n    \n    def _try_interpret_as_again_event(self, frame, original_event, original_args):\n        \"\"\"\n        Some after_* events can be interpreted also as \n        \"before_*_again\" events (eg. when last argument of a call was \n        evaluated, then we are just before executing the final stage of the call)\n        \"\"\"\n\n        if original_event == \"after_expression\":\n            node_tags = original_args.get(\"node_tags\")\n            value = original_args.get(\"value\")\n            \n            if (node_tags is not None \n                and (\"last_child\" in node_tags\n                     or \"or_arg\" in node_tags and value\n                     or \"and_arg\" in node_tags and not value)):\n                \n                # next step will be finalizing evaluation of parent of current expr\n                # so let's say we're before that parent expression\n                again_args = {\"text_range\" : original_args.get(\"parent_range\"),\n                              \"node_tags\" : \"\"}\n                again_event = (\"before_expression_again\" \n                               if \"child_of_expression\" in node_tags\n                               else \"before_statement_again\")\n                \n                self._handle_progress_event(frame, again_event, again_args)\n                \n    \n    def _respond_to_inline_commands(self):\n        while isinstance(self._current_command, InlineCommand): \n            self._vm.handle_command(self._current_command, \"waiting_debugger_command\")\n            self._current_command = self._vm._fetch_command()\n    \n    def _get_frame_source_info(self, frame):\n        if frame.f_code.co_name == \"<module>\":\n            obj = inspect.getmodule(frame)\n            lineno = 1\n        else:\n            obj = frame.f_code\n            lineno = obj.co_firstlineno\n        \n        # lineno returned by getsourcelines is not consistent between modules vs functions\n        lines, _ = inspect.getsourcelines(obj) \n        return \"\".join(lines), lineno\n        \n    \n    \n    def _cmd_exec_completed(self, frame, event, args, focus, cmd):\n        \"\"\"\n        Identifies the moment when piece of code indicated by cmd.frame_id and cmd.focus\n        has completed execution (either successfully or not).\n        \"\"\"\n        \n        # it's meant to be executed in before* state, but if we're not there\n        # we'll step there\n        \n        if cmd.state not in (\"before_expression\", \"before_expression_again\",\n                             \"before_statement\", \"before_statement_again\"):\n            return self._cmd_step_completed(frame, event, args, focus, cmd)\n        \n        \n        if id(frame) == cmd.frame_id:\n            \n            if focus.is_smaller_in(cmd.focus):\n                # we're executing a child of command focus,\n                # keep running\n                return False \n            \n            elif focus == cmd.focus:\n                \n                if event.startswith(\"before_\"):\n                    # we're just starting\n                    return False\n                \n                elif (event == \"after_expression\"\n                      and cmd.state in (\"before_expression\", \"before_expression_again\")\n                      or \n                      event == \"after_statement\"\n                      and cmd.state in (\"before_statement\", \"before_statement_again\")):\n                    # Normal completion\n                    # Maybe there was an exception, but this is forgotten now\n                    cmd._unhandled_exception = False\n                    self._debug(\"Exec normal\")\n                    return True\n                \n                \n                elif (cmd.state in (\"before_statement\", \"before_statement_again\")\n                      and event == \"after_expression\"):\n                    # Same code range can contain expression statement and expression.\n                    # Here we need to run just a bit more\n                    return False\n                \n                else:\n                    # shouldn't be here\n                    raise AssertionError(\"Unexpected state in responding to \" + str(cmd))\n                    \n            else:\n                # We're outside of starting focus, assumedly because of an exception\n                self._debug(\"Exec outside\", cmd.focus, focus)\n                return True\n        \n        else:\n            # We're in another frame\n            if self._frame_is_alive(cmd.frame_id):\n                # We're in a successor frame, keep running\n                return False\n            else:\n                # Original frame has completed, assumedly because of an exception\n                # We're done\n                self._debug(\"Exec wrong frame\")\n                return True\n            \n\n    \n    def _cmd_step_completed(self, frame, event, args, focus, cmd):\n        return True\n    \n    def _cmd_run_to_before_completed(self, frame, event, args, focus, cmd):\n        return event.startswith(\"before\")\n    \n    def _cmd_out_completed(self, frame, event, args, focus, cmd):\n        \"\"\"Complete current frame\"\"\"\n        return (\n            # the frame has completed\n            not self._frame_is_alive(cmd.frame_id)\n            # we're in the same frame but on higher level \n            or id(frame) == cmd.frame_id and focus.contains_smaller(cmd.focus)\n        )\n    \n    \n    def _cmd_line_completed(self, frame, event, args, focus, cmd):\n        return (event == \"before_statement\" \n            and os.path.normcase(frame.f_code.co_filename) == os.path.normcase(cmd.target_filename)\n            and focus.lineno == cmd.target_lineno\n            and (focus != cmd.focus or id(frame) != cmd.frame_id))\n\n    \n    def _frame_is_alive(self, frame_id):\n        for frame in self._custom_stack:\n            if frame.id == frame_id:\n                return True\n        else:\n            return False \n    \n    def _export_stack(self):\n        result = []\n        \n        for custom_frame in self._custom_stack:\n            \n            last_event_args = custom_frame.last_event_args.copy()\n            if \"value\" in last_event_args:\n                last_event_args[\"value\"] = self._vm.export_value(last_event_args[\"value\"]) \n            \n            system_frame = custom_frame.system_frame\n            source, firstlineno = self._get_frame_source_info(system_frame)\n            \n            result.append(FrameInfo(\n                id=id(system_frame),\n                filename=system_frame.f_code.co_filename,\n                module_name=system_frame.f_globals[\"__name__\"],\n                code_name=system_frame.f_code.co_name,\n                locals=self._vm.export_variables(system_frame.f_locals),\n                source=source,\n                firstlineno=firstlineno,\n                last_event=custom_frame.last_event,\n                last_event_args=last_event_args,\n                last_event_focus=custom_frame.last_event_focus,\n            ))\n        \n        return result\n\n    def _thonny_hidden_before_stmt(self, text_range, node_tags):\n        \"\"\"\n        The code to be debugged will be instrumented with this function\n        inserted before each statement. \n        Entry into this function indicates that statement as given\n        by the code range is about to be evaluated next.\n        \"\"\"\n        return None\n    \n    def _thonny_hidden_after_stmt(self, text_range, node_tags):\n        \"\"\"\n        The code to be debugged will be instrumented with this function\n        inserted after each statement. \n        Entry into this function indicates that statement as given\n        by the code range was just executed successfully.\n        \"\"\"\n        return None\n    \n    def _thonny_hidden_before_expr(self, text_range, node_tags):\n        \"\"\"\n        Entry into this function indicates that expression as given\n        by the code range is about to be evaluated next\n        \"\"\" \n        return text_range\n    \n    def _thonny_hidden_after_expr(self, text_range, node_tags, value, parent_range):\n        \"\"\"\n        The code to be debugged will be instrumented with this function\n        wrapped around each expression (given as 2nd argument). \n        Entry into this function indicates that expression as given\n        by the code range was just evaluated to given value\n        \"\"\" \n        return value\n    \n\n    def _tag_nodes(self, root):\n        \"\"\"Marks interesting properties of AST nodes\"\"\"\n        \n        def add_tag(node, tag):\n            if not hasattr(node, \"tags\"):\n                node.tags = set()\n                node.tags.add(\"class=\" + node.__class__.__name__)\n            node.tags.add(tag)\n        \n        for node in ast.walk(root):\n            \n            # tag last children \n            last_child = ast_utils.get_last_child(node)\n            if last_child is not None and last_child:\n                add_tag(node, \"has_children\")\n                \n                if isinstance(last_child, ast.AST):\n                    last_child.parent_node = node\n                    add_tag(last_child, \"last_child\")\n                    if isinstance(node, _ast.expr):\n                        add_tag(last_child, \"child_of_expression\")\n                    else:\n                        add_tag(last_child, \"child_of_statement\")\n                    \n                    if isinstance(node, ast.Call):\n                        add_tag(last_child, \"last_call_arg\")\n                    \n            # other cases\n            if isinstance(node, ast.Call):\n                add_tag(node.func, \"call_function\")\n                node.func.parent_node = node\n                \n            if isinstance(node, ast.BoolOp) and node.op == ast.Or():\n                for child in node.values:\n                    add_tag(child, \"or_arg\")\n                    child.parent_node = node\n                    \n            if isinstance(node, ast.BoolOp) and node.op == ast.And():\n                for child in node.values:\n                    add_tag(child, \"and_arg\")\n                    child.parent_node = node\n            \n            # TODO: assert (it doesn't evaluate msg when test == True)\n            \n            if isinstance(node, ast.Str):\n                add_tag(node, \"StringLiteral\")\n                \n            if isinstance(node, ast.Num):\n                add_tag(node, \"NumberLiteral\")\n            \n            if isinstance(node, ast.ListComp):\n                add_tag(node.elt, \"ListComp.elt\")\n                \n            if isinstance(node, ast.SetComp):\n                add_tag(node.elt, \"SetComp.elt\")\n                \n            if isinstance(node, ast.DictComp):\n                add_tag(node.key, \"DictComp.key\")\n                add_tag(node.value, \"DictComp.value\")\n            \n            if isinstance(node, ast.comprehension):\n                for expr in node.ifs:\n                    add_tag(expr, \"comprehension.if\")\n                \n                \n            # make sure every node has this field\n            if not hasattr(node, \"tags\"):\n                node.tags = set()\n            \n    \n    def _should_instrument_as_expression(self, node):\n        return (isinstance(node, _ast.expr)\n                and (not hasattr(node, \"ctx\") or isinstance(node.ctx, ast.Load))\n                # TODO: repeatedly evaluated subexpressions of comprehensions\n                # can be supported (but it requires some redesign both in backend and GUI)\n                and \"ListComp.elt\" not in node.tags \n                and \"SetComp.elt\" not in node.tags\n                and \"DictComp.key\" not in node.tags\n                and \"DictComp.value\" not in node.tags\n                and \"comprehension.if\" not in node.tags\n                )         \n        return \n    \n    def _should_instrument_as_statement(self, node):\n        return (isinstance(node, _ast.stmt)\n                # Shouldn't insert anything before from __future__ import\n                # as this is not a normal statement\n                # https://bitbucket.org/plas/thonny/issues/183/thonny-throws-false-positive-syntaxerror\n                and (not isinstance(node, _ast.ImportFrom)\n                     or node.module != \"__future__\"))\n    \n    def _insert_statement_markers(self, root):\n        # find lists of statements and insert before/after markers for each statement\n        for name, value in ast.iter_fields(root):\n            if isinstance(value, ast.AST):\n                self._insert_statement_markers(value)\n            elif isinstance(value, list):\n                if len(value) > 0:\n                    new_list = []\n                    for node in value:\n                        if self._should_instrument_as_statement(node):\n                            # self._debug(\"EBFOMA\", node)\n                            # add before marker\n                            new_list.append(self._create_statement_marker(node, \n                                                                          BEFORE_STATEMENT_MARKER))\n                        \n                        # original statement\n                        if self._should_instrument_as_statement(node):\n                            self._insert_statement_markers(node)\n                        new_list.append(node)\n                        \n                        if isinstance(node, _ast.stmt):\n                            # add after marker\n                            new_list.append(self._create_statement_marker(node,\n                                                                          AFTER_STATEMENT_MARKER))\n                    setattr(root, name, new_list)\n    \n    \n    def _create_statement_marker(self, node, function_name):\n        call = self._create_simple_marker_call(node, function_name)\n        stmt = ast.Expr(value=call)\n        ast.copy_location(stmt, node)\n        ast.fix_missing_locations(stmt)\n        return stmt\n        \n    \n    def _insert_expression_markers(self, node):\n        \"\"\"\n        each expression e gets wrapped like this:\n            _after(_before(_loc, _node_is_zoomable), e, _node_role, _parent_range)\n        where\n            _after is function that gives the resulting value\n            _before is function that signals the beginning of evaluation of e\n            _loc gives the code range of e\n            _node_is_zoomable indicates whether this node has subexpressions\n            _node_role is either 'last_call_arg', 'last_op_arg', 'first_or_arg', \n                                 'first_and_arg', 'function' or None\n        \"\"\"\n        tracer = self\n        \n        class ExpressionVisitor(ast.NodeTransformer):\n            def generic_visit(self, node):\n                if isinstance(node, _ast.expr):\n                    if isinstance(node, ast.Starred):\n                        # keep this node as is, but instrument its children\n                        return ast.NodeTransformer.generic_visit(self, node)\n                    elif tracer._should_instrument_as_expression(node):\n                        # before marker \n                        before_marker = tracer._create_simple_marker_call(node, BEFORE_EXPRESSION_MARKER)\n                        ast.copy_location(before_marker, node)\n                        \n                        # after marker\n                        after_marker = ast.Call (\n                            func=ast.Name(id=AFTER_EXPRESSION_MARKER, ctx=ast.Load()),\n                            args=[\n                                before_marker,\n                                tracer._create_tags_literal(node),\n                                ast.NodeTransformer.generic_visit(self, node),\n                                tracer._create_location_literal(node.parent_node if hasattr(node, \"parent_node\") else None)\n                            ],\n                            keywords=[]\n                        )\n                        ast.copy_location(after_marker, node)\n                        ast.fix_missing_locations(after_marker)\n                        \n                        return after_marker\n                    else:\n                        # This expression (and its children) should be ignored\n                        return node\n                else:\n                    # Descend into statements\n                    return ast.NodeTransformer.generic_visit(self, node)\n        \n        return ExpressionVisitor().visit(node)   \n            \n    \n    def _create_location_literal(self, node):\n        if node is None:\n            return ast_utils.value_to_literal(None)\n        \n        assert hasattr(node, \"end_lineno\")\n        assert hasattr(node, \"end_col_offset\")\n        \n        nums = []\n        for value in node.lineno, node.col_offset, node.end_lineno, node.end_col_offset:\n            nums.append(ast.Num(n=value))\n        return ast.Tuple(elts=nums, ctx=ast.Load())\n    \n    def _create_tags_literal(self, node):\n        if hasattr(node, \"tags\"):\n            # maybe set would perform as well, but I think string is faster\n            return ast_utils.value_to_literal(\",\".join(node.tags))\n            #self._debug(\"YESTAGS\")\n        else:\n            #self._debug(\"NOTAGS \" + str(node))\n            return ast_utils.value_to_literal(\"\")\n    \n    def _create_simple_marker_call(self, node, fun_name):\n        assert hasattr(node, \"end_lineno\")\n        assert hasattr(node, \"end_col_offset\")\n        \n        args = [\n            self._create_location_literal(node),\n            self._create_tags_literal(node),\n        ]\n        \n        return ast.Call (\n            func=ast.Name(id=fun_name, ctx=ast.Load()),\n            args=args,\n            keywords=[]\n        )\n    \n    def _debug(self, *args):\n        print(\"TRACER:\", *args, file=self._vm._original_stderr)\n\nclass CustomStackFrame:\n    def __init__(self, frame, last_event, focus=None):\n        self.id = id(frame)\n        self.system_frame = frame\n        self.last_event = last_event\n        self.focus = None\n        \nclass ThonnyClientError(Exception):\n    pass\n    \n\ndef fdebug(frame, msg, *args):\n    if logger.isEnabledFor(logging.DEBUG):\n        logger.debug(_get_frame_prefix(frame) + msg, *args)\n    \n    \ndef _get_frame_prefix(frame):\n    return str(id(frame)) + \" \" + \">\" * len(inspect.getouterframes(frame, 0)) + \" \"\n    \ndef _get_python_version_string(add_word_size=False):\n    result = \".\".join(map(str, sys.version_info[:3]))\n    if sys.version_info[3] != \"final\":\n        result += \"-\" + sys.version_info[3]\n    \n    if add_word_size:\n        result += \" (\" + (\"64\" if sys.maxsize > 2**32 else \"32\")+ \" bit)\"\n    \n    return result    \n\nclass _PathSet:\n    \"implementation of set whose in operator works well for filenames\"\n    def __init__(self):\n        self._normcase_set = set()\n        \n    def add(self, name):\n        self._normcase_set.add(os.path.normcase(name))\n    \n    def remove(self, name):\n        self._normcase_set.remove(os.path.normcase(name))\n    \n    def clear(self):\n        self._normcase_set.clear()\n    \n    def __contains__(self, name):\n        return os.path.normcase(name) in self._normcase_set\n\n    def __iter__(self):\n        for item in self._normcase_set:\n            yield item\n"
    },
    {
        "sequence": "<Button-1>",
        "widget_class": "Editor",
        "widget_id": 1926726864,
        "time": "2018-07-19T21:12:17.309871"
    },
    {
        "sequence": "<Button-1>",
        "widget_class": "EditorNotebook",
        "widget_id": 1970459376,
        "time": "2018-07-19T21:12:17.349488"
    },
    {
        "sequence": "<Button-1>",
        "widget_class": "EditorNotebook",
        "widget_id": 1970459376,
        "time": "2018-07-19T21:12:17.353762"
    },
    {
        "sequence": "<Button-1>",
        "widget_class": "EditorNotebook",
        "widget_id": 1970459376,
        "time": "2018-07-19T21:12:17.355229"
    },
    {
        "sequence": "<Button-1>",
        "widget_class": "EditorNotebook",
        "widget_id": 1970459376,
        "time": "2018-07-19T21:12:17.356671"
    },
    {
        "sequence": "<Button-1>",
        "widget_class": "EditorNotebook",
        "widget_id": 1970459376,
        "time": "2018-07-19T21:12:17.559356"
    },
    {
        "sequence": "<Button-1>",
        "widget_class": "EditorNotebook",
        "widget_id": 1970459376,
        "time": "2018-07-19T21:12:17.976833"
    },
    {
        "text_widget_id": 1970638992,
        "sequence": "<Button-1>",
        "text_widget_class": "CodeViewText",
        "widget_id": 1970638992,
        "time": "2018-07-19T21:12:18.516060",
        "widget_class": "CodeViewText"
    },
    {
        "text_widget_id": 1970495696,
        "sequence": "<Button-1>",
        "text_widget_class": "ShellText",
        "widget_id": 1970495696,
        "time": "2018-07-19T21:12:21.492906",
        "widget_class": "ShellText",
        "text_widget_context": "shell"
    },
    {
        "text_widget_id": 1926726256,
        "sequence": "EditorTextCreated",
        "text_widget_class": "CodeViewText",
        "editor_id": 1926729072,
        "time": "2018-07-19T21:12:21.624716",
        "editor_class": "Editor"
    },
    {
        "text_widget_id": 1926726256,
        "sequence": "Open",
        "text_widget_class": "CodeViewText",
        "editor_id": 1926729072,
        "time": "2018-07-19T21:12:21.625639",
        "filename": "/usr/lib/python3.5/tokenize.py",
        "editor_class": "Editor"
    },
    {
        "index1": "1.0",
        "sequence": "TextDelete",
        "text_widget_class": "CodeViewText",
        "time": "2018-07-19T21:12:21.627661",
        "text_widget_id": 1926726256,
        "index2": "2.0"
    },
    {
        "text_widget_id": 1926726256,
        "index": "1.0",
        "text_widget_class": "CodeViewText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:21.658933",
        "tags": "()",
        "text": "\"\"\"Tokenization help for Python programs.\n\ntokenize(readline) is a generator that breaks a stream of bytes into\nPython tokens.  It decodes the bytes according to PEP-0263 for\ndetermining source file encoding.\n\nIt accepts a readline-like method which is called repeatedly to get the\nnext line of input (or b\"\" for EOF).  It generates 5-tuples with these\nmembers:\n\n    the token type (see token.py)\n    the token (a string)\n    the starting (row, column) indices of the token (a 2-tuple of ints)\n    the ending (row, column) indices of the token (a 2-tuple of ints)\n    the original line (string)\n\nIt is designed to match the working of the Python tokenizer exactly, except\nthat it produces COMMENT tokens for comments and gives type OP for all\noperators.  Additionally, all token lists start with an ENCODING token\nwhich tells you which encoding was used to decode the bytes stream.\n\"\"\"\n\n__author__ = 'Ka-Ping Yee <ping@lfw.org>'\n__credits__ = ('GvR, ESR, Tim Peters, Thomas Wouters, Fred Drake, '\n               'Skip Montanaro, Raymond Hettinger, Trent Nelson, '\n               'Michael Foord')\nfrom builtins import open as _builtin_open\nfrom codecs import lookup, BOM_UTF8\nimport collections\nfrom io import TextIOWrapper\nfrom itertools import chain\nimport re\nimport sys\nfrom token import *\n\ncookie_re = re.compile(r'^[ \\t\\f]*#.*?coding[:=][ \\t]*([-\\w.]+)', re.ASCII)\nblank_re = re.compile(br'^[ \\t\\f]*(?:[#\\r\\n]|$)', re.ASCII)\n\nimport token\n__all__ = token.__all__ + [\"COMMENT\", \"tokenize\", \"detect_encoding\",\n                           \"NL\", \"untokenize\", \"ENCODING\", \"TokenInfo\"]\ndel token\n\nCOMMENT = N_TOKENS\ntok_name[COMMENT] = 'COMMENT'\nNL = N_TOKENS + 1\ntok_name[NL] = 'NL'\nENCODING = N_TOKENS + 2\ntok_name[ENCODING] = 'ENCODING'\nN_TOKENS += 3\nEXACT_TOKEN_TYPES = {\n    '(':   LPAR,\n    ')':   RPAR,\n    '[':   LSQB,\n    ']':   RSQB,\n    ':':   COLON,\n    ',':   COMMA,\n    ';':   SEMI,\n    '+':   PLUS,\n    '-':   MINUS,\n    '*':   STAR,\n    '/':   SLASH,\n    '|':   VBAR,\n    '&':   AMPER,\n    '<':   LESS,\n    '>':   GREATER,\n    '=':   EQUAL,\n    '.':   DOT,\n    '%':   PERCENT,\n    '{':   LBRACE,\n    '}':   RBRACE,\n    '==':  EQEQUAL,\n    '!=':  NOTEQUAL,\n    '<=':  LESSEQUAL,\n    '>=':  GREATEREQUAL,\n    '~':   TILDE,\n    '^':   CIRCUMFLEX,\n    '<<':  LEFTSHIFT,\n    '>>':  RIGHTSHIFT,\n    '**':  DOUBLESTAR,\n    '+=':  PLUSEQUAL,\n    '-=':  MINEQUAL,\n    '*=':  STAREQUAL,\n    '/=':  SLASHEQUAL,\n    '%=':  PERCENTEQUAL,\n    '&=':  AMPEREQUAL,\n    '|=':  VBAREQUAL,\n    '^=': CIRCUMFLEXEQUAL,\n    '<<=': LEFTSHIFTEQUAL,\n    '>>=': RIGHTSHIFTEQUAL,\n    '**=': DOUBLESTAREQUAL,\n    '//':  DOUBLESLASH,\n    '//=': DOUBLESLASHEQUAL,\n    '@':   AT,\n    '@=':  ATEQUAL,\n}\n\nclass TokenInfo(collections.namedtuple('TokenInfo', 'type string start end line')):\n    def __repr__(self):\n        annotated_type = '%d (%s)' % (self.type, tok_name[self.type])\n        return ('TokenInfo(type=%s, string=%r, start=%r, end=%r, line=%r)' %\n                self._replace(type=annotated_type))\n\n    @property\n    def exact_type(self):\n        if self.type == OP and self.string in EXACT_TOKEN_TYPES:\n            return EXACT_TOKEN_TYPES[self.string]\n        else:\n            return self.type\n\ndef group(*choices): return '(' + '|'.join(choices) + ')'\ndef any(*choices): return group(*choices) + '*'\ndef maybe(*choices): return group(*choices) + '?'\n\n# Note: we use unicode matching for names (\"\\w\") but ascii matching for\n# number literals.\nWhitespace = r'[ \\f\\t]*'\nComment = r'#[^\\r\\n]*'\nIgnore = Whitespace + any(r'\\\\\\r?\\n' + Whitespace) + maybe(Comment)\nName = r'\\w+'\n\nHexnumber = r'0[xX][0-9a-fA-F]+'\nBinnumber = r'0[bB][01]+'\nOctnumber = r'0[oO][0-7]+'\nDecnumber = r'(?:0+|[1-9][0-9]*)'\nIntnumber = group(Hexnumber, Binnumber, Octnumber, Decnumber)\nExponent = r'[eE][-+]?[0-9]+'\nPointfloat = group(r'[0-9]+\\.[0-9]*', r'\\.[0-9]+') + maybe(Exponent)\nExpfloat = r'[0-9]+' + Exponent\nFloatnumber = group(Pointfloat, Expfloat)\nImagnumber = group(r'[0-9]+[jJ]', Floatnumber + r'[jJ]')\nNumber = group(Imagnumber, Floatnumber, Intnumber)\n\nStringPrefix = r'(?:[bB][rR]?|[rR][bB]?|[uU])?'\n\n# Tail end of ' string.\nSingle = r\"[^'\\\\]*(?:\\\\.[^'\\\\]*)*'\"\n# Tail end of \" string.\nDouble = r'[^\"\\\\]*(?:\\\\.[^\"\\\\]*)*\"'\n# Tail end of ''' string.\nSingle3 = r\"[^'\\\\]*(?:(?:\\\\.|'(?!''))[^'\\\\]*)*'''\"\n# Tail end of \"\"\" string.\nDouble3 = r'[^\"\\\\]*(?:(?:\\\\.|\"(?!\"\"))[^\"\\\\]*)*\"\"\"'\nTriple = group(StringPrefix + \"'''\", StringPrefix + '\"\"\"')\n# Single-line ' or \" string.\nString = group(StringPrefix + r\"'[^\\n'\\\\]*(?:\\\\.[^\\n'\\\\]*)*'\",\n               StringPrefix + r'\"[^\\n\"\\\\]*(?:\\\\.[^\\n\"\\\\]*)*\"')\n\n# Because of leftmost-then-longest match semantics, be sure to put the\n# longest operators first (e.g., if = came before ==, == would get\n# recognized as two instances of =).\nOperator = group(r\"\\*\\*=?\", r\">>=?\", r\"<<=?\", r\"!=\",\n                 r\"//=?\", r\"->\",\n                 r\"[+\\-*/%&@|^=<>]=?\",\n                 r\"~\")\n\nBracket = '[][(){}]'\nSpecial = group(r'\\r?\\n', r'\\.\\.\\.', r'[:;.,@]')\nFunny = group(Operator, Bracket, Special)\n\nPlainToken = group(Number, Funny, String, Name)\nToken = Ignore + PlainToken\n\n# First (or only) line of ' or \" string.\nContStr = group(StringPrefix + r\"'[^\\n'\\\\]*(?:\\\\.[^\\n'\\\\]*)*\" +\n                group(\"'\", r'\\\\\\r?\\n'),\n                StringPrefix + r'\"[^\\n\"\\\\]*(?:\\\\.[^\\n\"\\\\]*)*' +\n                group('\"', r'\\\\\\r?\\n'))\nPseudoExtras = group(r'\\\\\\r?\\n|\\Z', Comment, Triple)\nPseudoToken = Whitespace + group(PseudoExtras, Number, Funny, ContStr, Name)\n\ndef _compile(expr):\n    return re.compile(expr, re.UNICODE)\n\nendpats = {\"'\": Single, '\"': Double,\n           \"'''\": Single3, '\"\"\"': Double3,\n           \"r'''\": Single3, 'r\"\"\"': Double3,\n           \"b'''\": Single3, 'b\"\"\"': Double3,\n           \"R'''\": Single3, 'R\"\"\"': Double3,\n           \"B'''\": Single3, 'B\"\"\"': Double3,\n           \"br'''\": Single3, 'br\"\"\"': Double3,\n           \"bR'''\": Single3, 'bR\"\"\"': Double3,\n           \"Br'''\": Single3, 'Br\"\"\"': Double3,\n           \"BR'''\": Single3, 'BR\"\"\"': Double3,\n           \"rb'''\": Single3, 'rb\"\"\"': Double3,\n           \"Rb'''\": Single3, 'Rb\"\"\"': Double3,\n           \"rB'''\": Single3, 'rB\"\"\"': Double3,\n           \"RB'''\": Single3, 'RB\"\"\"': Double3,\n           \"u'''\": Single3, 'u\"\"\"': Double3,\n           \"U'''\": Single3, 'U\"\"\"': Double3,\n           'r': None, 'R': None, 'b': None, 'B': None,\n           'u': None, 'U': None}\n\ntriple_quoted = {}\nfor t in (\"'''\", '\"\"\"',\n          \"r'''\", 'r\"\"\"', \"R'''\", 'R\"\"\"',\n          \"b'''\", 'b\"\"\"', \"B'''\", 'B\"\"\"',\n          \"br'''\", 'br\"\"\"', \"Br'''\", 'Br\"\"\"',\n          \"bR'''\", 'bR\"\"\"', \"BR'''\", 'BR\"\"\"',\n          \"rb'''\", 'rb\"\"\"', \"rB'''\", 'rB\"\"\"',\n          \"Rb'''\", 'Rb\"\"\"', \"RB'''\", 'RB\"\"\"',\n          \"u'''\", 'u\"\"\"', \"U'''\", 'U\"\"\"',\n          ):\n    triple_quoted[t] = t\nsingle_quoted = {}\nfor t in (\"'\", '\"',\n          \"r'\", 'r\"', \"R'\", 'R\"',\n          \"b'\", 'b\"', \"B'\", 'B\"',\n          \"br'\", 'br\"', \"Br'\", 'Br\"',\n          \"bR'\", 'bR\"', \"BR'\", 'BR\"' ,\n          \"rb'\", 'rb\"', \"rB'\", 'rB\"',\n          \"Rb'\", 'Rb\"', \"RB'\", 'RB\"' ,\n          \"u'\", 'u\"', \"U'\", 'U\"',\n          ):\n    single_quoted[t] = t\n\ntabsize = 8\n\nclass TokenError(Exception): pass\n\nclass StopTokenizing(Exception): pass\n\n\nclass Untokenizer:\n\n    def __init__(self):\n        self.tokens = []\n        self.prev_row = 1\n        self.prev_col = 0\n        self.encoding = None\n\n    def add_whitespace(self, start):\n        row, col = start\n        if row < self.prev_row or row == self.prev_row and col < self.prev_col:\n            raise ValueError(\"start ({},{}) precedes previous end ({},{})\"\n                             .format(row, col, self.prev_row, self.prev_col))\n        row_offset = row - self.prev_row\n        if row_offset:\n            self.tokens.append(\"\\\\\\n\" * row_offset)\n            self.prev_col = 0\n        col_offset = col - self.prev_col\n        if col_offset:\n            self.tokens.append(\" \" * col_offset)\n\n    def untokenize(self, iterable):\n        it = iter(iterable)\n        indents = []\n        startline = False\n        for t in it:\n            if len(t) == 2:\n                self.compat(t, it)\n                break\n            tok_type, token, start, end, line = t\n            if tok_type == ENCODING:\n                self.encoding = token\n                continue\n            if tok_type == ENDMARKER:\n                break\n            if tok_type == INDENT:\n                indents.append(token)\n                continue\n            elif tok_type == DEDENT:\n                indents.pop()\n                self.prev_row, self.prev_col = end\n                continue\n            elif tok_type in (NEWLINE, NL):\n                startline = True\n            elif startline and indents:\n                indent = indents[-1]\n                if start[1] >= len(indent):\n                    self.tokens.append(indent)\n                    self.prev_col = len(indent)\n                startline = False\n            self.add_whitespace(start)\n            self.tokens.append(token)\n            self.prev_row, self.prev_col = end\n            if tok_type in (NEWLINE, NL):\n                self.prev_row += 1\n                self.prev_col = 0\n        return \"\".join(self.tokens)\n\n    def compat(self, token, iterable):\n        indents = []\n        toks_append = self.tokens.append\n        startline = token[0] in (NEWLINE, NL)\n        prevstring = False\n\n        for tok in chain([token], iterable):\n            toknum, tokval = tok[:2]\n            if toknum == ENCODING:\n                self.encoding = tokval\n                continue\n\n            if toknum in (NAME, NUMBER, ASYNC, AWAIT):\n                tokval += ' '\n\n            # Insert a space between two consecutive strings\n            if toknum == STRING:\n                if prevstring:\n                    tokval = ' ' + tokval\n                prevstring = True\n            else:\n                prevstring = False\n\n            if toknum == INDENT:\n                indents.append(tokval)\n                continue\n            elif toknum == DEDENT:\n                indents.pop()\n                continue\n            elif toknum in (NEWLINE, NL):\n                startline = True\n            elif startline and indents:\n                toks_append(indents[-1])\n                startline = False\n            toks_append(tokval)\n\n\ndef untokenize(iterable):\n    \"\"\"Transform tokens back into Python source code.\n    It returns a bytes object, encoded using the ENCODING\n    token, which is the first token sequence output by tokenize.\n\n    Each element returned by the iterable must be a token sequence\n    with at least two elements, a token number and token value.  If\n    only two tokens are passed, the resulting output is poor.\n\n    Round-trip invariant for full input:\n        Untokenized source will match input source exactly\n\n    Round-trip invariant for limited input:\n        # Output bytes will tokenize back to the input\n        t1 = [tok[:2] for tok in tokenize(f.readline)]\n        newcode = untokenize(t1)\n        readline = BytesIO(newcode).readline\n        t2 = [tok[:2] for tok in tokenize(readline)]\n        assert t1 == t2\n    \"\"\"\n    ut = Untokenizer()\n    out = ut.untokenize(iterable)\n    if ut.encoding is not None:\n        out = out.encode(ut.encoding)\n    return out\n\n\ndef _get_normal_name(orig_enc):\n    \"\"\"Imitates get_normal_name in tokenizer.c.\"\"\"\n    # Only care about the first 12 characters.\n    enc = orig_enc[:12].lower().replace(\"_\", \"-\")\n    if enc == \"utf-8\" or enc.startswith(\"utf-8-\"):\n        return \"utf-8\"\n    if enc in (\"latin-1\", \"iso-8859-1\", \"iso-latin-1\") or \\\n       enc.startswith((\"latin-1-\", \"iso-8859-1-\", \"iso-latin-1-\")):\n        return \"iso-8859-1\"\n    return orig_enc\n\ndef detect_encoding(readline):\n    \"\"\"\n    The detect_encoding() function is used to detect the encoding that should\n    be used to decode a Python source file.  It requires one argument, readline,\n    in the same way as the tokenize() generator.\n\n    It will call readline a maximum of twice, and return the encoding used\n    (as a string) and a list of any lines (left as bytes) it has read in.\n\n    It detects the encoding from the presence of a utf-8 bom or an encoding\n    cookie as specified in pep-0263.  If both a bom and a cookie are present,\n    but disagree, a SyntaxError will be raised.  If the encoding cookie is an\n    invalid charset, raise a SyntaxError.  Note that if a utf-8 bom is found,\n    'utf-8-sig' is returned.\n\n    If no encoding is specified, then the default of 'utf-8' will be returned.\n    \"\"\"\n    try:\n        filename = readline.__self__.name\n    except AttributeError:\n        filename = None\n    bom_found = False\n    encoding = None\n    default = 'utf-8'\n    def read_or_stop():\n        try:\n            return readline()\n        except StopIteration:\n            return b''\n\n    def find_cookie(line):\n        try:\n            # Decode as UTF-8. Either the line is an encoding declaration,\n            # in which case it should be pure ASCII, or it must be UTF-8\n            # per default encoding.\n            line_string = line.decode('utf-8')\n        except UnicodeDecodeError:\n            msg = \"invalid or missing encoding declaration\"\n            if filename is not None:\n                msg = '{} for {!r}'.format(msg, filename)\n            raise SyntaxError(msg)\n\n        match = cookie_re.match(line_string)\n        if not match:\n            return None\n        encoding = _get_normal_name(match.group(1))\n        try:\n            codec = lookup(encoding)\n        except LookupError:\n            # This behaviour mimics the Python interpreter\n            if filename is None:\n                msg = \"unknown encoding: \" + encoding\n            else:\n                msg = \"unknown encoding for {!r}: {}\".format(filename,\n                        encoding)\n            raise SyntaxError(msg)\n\n        if bom_found:\n            if encoding != 'utf-8':\n                # This behaviour mimics the Python interpreter\n                if filename is None:\n                    msg = 'encoding problem: utf-8'\n                else:\n                    msg = 'encoding problem for {!r}: utf-8'.format(filename)\n                raise SyntaxError(msg)\n            encoding += '-sig'\n        return encoding\n\n    first = read_or_stop()\n    if first.startswith(BOM_UTF8):\n        bom_found = True\n        first = first[3:]\n        default = 'utf-8-sig'\n    if not first:\n        return default, []\n\n    encoding = find_cookie(first)\n    if encoding:\n        return encoding, [first]\n    if not blank_re.match(first):\n        return default, [first]\n\n    second = read_or_stop()\n    if not second:\n        return default, [first]\n\n    encoding = find_cookie(second)\n    if encoding:\n        return encoding, [first, second]\n\n    return default, [first, second]\n\n\ndef open(filename):\n    \"\"\"Open a file in read only mode using the encoding detected by\n    detect_encoding().\n    \"\"\"\n    buffer = _builtin_open(filename, 'rb')\n    try:\n        encoding, lines = detect_encoding(buffer.readline)\n        buffer.seek(0)\n        text = TextIOWrapper(buffer, encoding, line_buffering=True)\n        text.mode = 'r'\n        return text\n    except:\n        buffer.close()\n        raise\n\n\ndef tokenize(readline):\n    \"\"\"\n    The tokenize() generator requires one argument, readline, which\n    must be a callable object which provides the same interface as the\n    readline() method of built-in file objects.  Each call to the function\n    should return one line of input as bytes.  Alternatively, readline\n    can be a callable function terminating with StopIteration:\n        readline = open(myfile, 'rb').__next__  # Example of alternate readline\n\n    The generator produces 5-tuples with these members: the token type; the\n    token string; a 2-tuple (srow, scol) of ints specifying the row and\n    column where the token begins in the source; a 2-tuple (erow, ecol) of\n    ints specifying the row and column where the token ends in the source;\n    and the line on which the token was found.  The line passed is the\n    logical line; continuation lines are included.\n\n    The first token sequence will always be an ENCODING token\n    which tells you which encoding was used to decode the bytes stream.\n    \"\"\"\n    # This import is here to avoid problems when the itertools module is not\n    # built yet and tokenize is imported.\n    from itertools import chain, repeat\n    encoding, consumed = detect_encoding(readline)\n    rl_gen = iter(readline, b\"\")\n    empty = repeat(b\"\")\n    return _tokenize(chain(consumed, rl_gen, empty).__next__, encoding)\n\n\ndef _tokenize(readline, encoding):\n    lnum = parenlev = continued = 0\n    numchars = '0123456789'\n    contstr, needcont = '', 0\n    contline = None\n    indents = [0]\n\n    # 'stashed' and 'async_*' are used for async/await parsing\n    stashed = None\n    async_def = False\n    async_def_indent = 0\n    async_def_nl = False\n\n    if encoding is not None:\n        if encoding == \"utf-8-sig\":\n            # BOM will already have been stripped.\n            encoding = \"utf-8\"\n        yield TokenInfo(ENCODING, encoding, (0, 0), (0, 0), '')\n    while True:             # loop over lines in stream\n        try:\n            line = readline()\n        except StopIteration:\n            line = b''\n\n        if encoding is not None:\n            line = line.decode(encoding)\n        lnum += 1\n        pos, max = 0, len(line)\n\n        if contstr:                            # continued string\n            if not line:\n                raise TokenError(\"EOF in multi-line string\", strstart)\n            endmatch = endprog.match(line)\n            if endmatch:\n                pos = end = endmatch.end(0)\n                yield TokenInfo(STRING, contstr + line[:end],\n                       strstart, (lnum, end), contline + line)\n                contstr, needcont = '', 0\n                contline = None\n            elif needcont and line[-2:] != '\\\\\\n' and line[-3:] != '\\\\\\r\\n':\n                yield TokenInfo(ERRORTOKEN, contstr + line,\n                           strstart, (lnum, len(line)), contline)\n                contstr = ''\n                contline = None\n                continue\n            else:\n                contstr = contstr + line\n                contline = contline + line\n                continue\n\n        elif parenlev == 0 and not continued:  # new statement\n            if not line: break\n            column = 0\n            while pos < max:                   # measure leading whitespace\n                if line[pos] == ' ':\n                    column += 1\n                elif line[pos] == '\\t':\n                    column = (column//tabsize + 1)*tabsize\n                elif line[pos] == '\\f':\n                    column = 0\n                else:\n                    break\n                pos += 1\n            if pos == max:\n                break\n\n            if line[pos] in '#\\r\\n':           # skip comments or blank lines\n                if line[pos] == '#':\n                    comment_token = line[pos:].rstrip('\\r\\n')\n                    nl_pos = pos + len(comment_token)\n                    yield TokenInfo(COMMENT, comment_token,\n                           (lnum, pos), (lnum, pos + len(comment_token)), line)\n                    yield TokenInfo(NL, line[nl_pos:],\n                           (lnum, nl_pos), (lnum, len(line)), line)\n                else:\n                    yield TokenInfo((NL, COMMENT)[line[pos] == '#'], line[pos:],\n                           (lnum, pos), (lnum, len(line)), line)\n                continue\n\n            if column > indents[-1]:           # count indents or dedents\n                indents.append(column)\n                yield TokenInfo(INDENT, line[:pos], (lnum, 0), (lnum, pos), line)\n            while column < indents[-1]:\n                if column not in indents:\n                    raise IndentationError(\n                        \"unindent does not match any outer indentation level\",\n                        (\"<tokenize>\", lnum, pos, line))\n                indents = indents[:-1]\n\n                if async_def and async_def_indent >= indents[-1]:\n                    async_def = False\n                    async_def_nl = False\n                    async_def_indent = 0\n\n                yield TokenInfo(DEDENT, '', (lnum, pos), (lnum, pos), line)\n\n            if async_def and async_def_nl and async_def_indent >= indents[-1]:\n                async_def = False\n                async_def_nl = False\n                async_def_indent = 0\n\n        else:                                  # continued statement\n            if not line:\n                raise TokenError(\"EOF in multi-line statement\", (lnum, 0))\n            continued = 0\n\n        while pos < max:\n            pseudomatch = _compile(PseudoToken).match(line, pos)\n            if pseudomatch:                                # scan for tokens\n                start, end = pseudomatch.span(1)\n                spos, epos, pos = (lnum, start), (lnum, end), end\n                if start == end:\n                    continue\n                token, initial = line[start:end], line[start]\n\n                if (initial in numchars or                  # ordinary number\n                    (initial == '.' and token != '.' and token != '...')):\n                    yield TokenInfo(NUMBER, token, spos, epos, line)\n                elif initial in '\\r\\n':\n                    if stashed:\n                        yield stashed\n                        stashed = None\n                    if parenlev > 0:\n                        yield TokenInfo(NL, token, spos, epos, line)\n                    else:\n                        yield TokenInfo(NEWLINE, token, spos, epos, line)\n                        if async_def:\n                            async_def_nl = True\n\n                elif initial == '#':\n                    assert not token.endswith(\"\\n\")\n                    if stashed:\n                        yield stashed\n                        stashed = None\n                    yield TokenInfo(COMMENT, token, spos, epos, line)\n                elif token in triple_quoted:\n                    endprog = _compile(endpats[token])\n                    endmatch = endprog.match(line, pos)\n                    if endmatch:                           # all on one line\n                        pos = endmatch.end(0)\n                        token = line[start:pos]\n                        yield TokenInfo(STRING, token, spos, (lnum, pos), line)\n                    else:\n                        strstart = (lnum, start)           # multiple lines\n                        contstr = line[start:]\n                        contline = line\n                        break\n                elif initial in single_quoted or \\\n                    token[:2] in single_quoted or \\\n                    token[:3] in single_quoted:\n                    if token[-1] == '\\n':                  # continued string\n                        strstart = (lnum, start)\n                        endprog = _compile(endpats[initial] or\n                                           endpats[token[1]] or\n                                           endpats[token[2]])\n                        contstr, needcont = line[start:], 1\n                        contline = line\n                        break\n                    else:                                  # ordinary string\n                        yield TokenInfo(STRING, token, spos, epos, line)\n                elif initial.isidentifier():               # ordinary name\n                    if token in ('async', 'await'):\n                        if async_def:\n                            yield TokenInfo(\n                                ASYNC if token == 'async' else AWAIT,\n                                token, spos, epos, line)\n                            continue\n\n                    tok = TokenInfo(NAME, token, spos, epos, line)\n                    if token == 'async' and not stashed:\n                        stashed = tok\n                        continue\n\n                    if token == 'def':\n                        if (stashed\n                                and stashed.type == NAME\n                                and stashed.string == 'async'):\n\n                            async_def = True\n                            async_def_indent = indents[-1]\n\n                            yield TokenInfo(ASYNC, stashed.string,\n                                            stashed.start, stashed.end,\n                                            stashed.line)\n                            stashed = None\n\n                    if stashed:\n                        yield stashed\n                        stashed = None\n\n                    yield tok\n                elif initial == '\\\\':                      # continued stmt\n                    continued = 1\n                else:\n                    if initial in '([{':\n                        parenlev += 1\n                    elif initial in ')]}':\n                        parenlev -= 1\n                    if stashed:\n                        yield stashed\n                        stashed = None\n                    yield TokenInfo(OP, token, spos, epos, line)\n            else:\n                yield TokenInfo(ERRORTOKEN, line[pos],\n                           (lnum, pos), (lnum, pos+1), line)\n                pos += 1\n\n    if stashed:\n        yield stashed\n        stashed = None\n\n    for indent in indents[1:]:                 # pop remaining indent levels\n        yield TokenInfo(DEDENT, '', (lnum, 0), (lnum, 0), '')\n    yield TokenInfo(ENDMARKER, '', (lnum, 0), (lnum, 0), '')\n\n\n# An undocumented, backwards compatible, API for all the places in the standard\n# library that expect to be able to use tokenize with strings\ndef generate_tokens(readline):\n    return _tokenize(readline, None)\n\ndef main():\n    import argparse\n\n    # Helper error handling routines\n    def perror(message):\n        print(message, file=sys.stderr)\n\n    def error(message, filename=None, location=None):\n        if location:\n            args = (filename,) + location + (message,)\n            perror(\"%s:%d:%d: error: %s\" % args)\n        elif filename:\n            perror(\"%s: error: %s\" % (filename, message))\n        else:\n            perror(\"error: %s\" % message)\n        sys.exit(1)\n\n    # Parse the arguments and options\n    parser = argparse.ArgumentParser(prog='python -m tokenize')\n    parser.add_argument(dest='filename', nargs='?',\n                        metavar='filename.py',\n                        help='the file to tokenize; defaults to stdin')\n    parser.add_argument('-e', '--exact', dest='exact', action='store_true',\n                        help='display token names using the exact type')\n    args = parser.parse_args()\n\n    try:\n        # Tokenize the input\n        if args.filename:\n            filename = args.filename\n            with _builtin_open(filename, 'rb') as f:\n                tokens = list(tokenize(f.readline))\n        else:\n            filename = \"<stdin>\"\n            tokens = _tokenize(sys.stdin.readline, None)\n\n        # Output the tokenization\n        for token in tokens:\n            token_type = token.type\n            if args.exact:\n                token_type = token.exact_type\n            token_range = \"%d,%d-%d,%d:\" % (token.start + token.end)\n            print(\"%-20s%-15s%-15r\" %\n                  (token_range, tok_name[token_type], token.string))\n    except IndentationError as err:\n        line, column = err.args[1][1:3]\n        error(err.args[0], filename, (line, column))\n    except TokenError as err:\n        line, column = err.args[1]\n        error(err.args[0], filename, (line, column))\n    except SyntaxError as err:\n        error(err, filename)\n    except OSError as err:\n        error(err)\n    except KeyboardInterrupt:\n        print(\"interrupted\\n\")\n    except Exception as err:\n        perror(\"unexpected error: %s\" % err)\n        raise\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
        "sequence": "<Button-1>",
        "widget_class": "EditorNotebook",
        "widget_id": 1970459376,
        "time": "2018-07-19T21:12:23.721615"
    },
    {
        "sequence": "<FocusOut>",
        "widget_class": "Workbench",
        "widget_id": 1982950640,
        "time": "2018-07-19T21:12:23.906590"
    },
    {
        "sequence": "<Button-1>",
        "widget": ".__tk__messagebox.cancel",
        "time": "2018-07-19T21:12:25.185016"
    },
    {
        "sequence": "<Button-1>",
        "widget": ".__tk__messagebox.no",
        "time": "2018-07-19T21:12:28.240961"
    },
    {
        "sequence": "<Button-1>",
        "widget": ".__tk__messagebox.cancel",
        "time": "2018-07-19T21:12:28.873275"
    },
    {
        "sequence": "<FocusIn>",
        "widget_class": "Workbench",
        "widget_id": 1982950640,
        "time": "2018-07-19T21:12:28.986567"
    },
    {
        "sequence": "<Button-1>",
        "widget_class": "EditorNotebook",
        "widget_id": 1970459376,
        "time": "2018-07-19T21:12:30.533066"
    },
    {
        "sequence": "<Button-1>",
        "widget_class": "EditorNotebook",
        "widget_id": 1970459376,
        "time": "2018-07-19T21:12:31.405127"
    },
    {
        "sequence": "<Button-1>",
        "widget_class": "EditorNotebook",
        "widget_id": 1970459376,
        "time": "2018-07-19T21:12:32.545082"
    },
    {
        "text_widget_id": 1970553296,
        "sequence": "<Button-1>",
        "text_widget_class": "CodeViewText",
        "widget_id": 1970553296,
        "time": "2018-07-19T21:12:33.480991",
        "widget_class": "CodeViewText"
    },
    {
        "sequence": "<Button-1>",
        "widget_class": "EditorNotebook",
        "widget_id": 1970459376,
        "time": "2018-07-19T21:12:34.951403"
    },
    {
        "text_widget_id": 1970638992,
        "sequence": "<Button-1>",
        "text_widget_class": "CodeViewText",
        "widget_id": 1970638992,
        "time": "2018-07-19T21:12:36.385239",
        "widget_class": "CodeViewText"
    },
    {
        "text_widget_id": 1970638992,
        "index": "18.2",
        "text_widget_class": "CodeViewText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:37.412086",
        "tags": "None",
        "text": "$"
    },
    {
        "text_widget_id": 1970638992,
        "index": "18.3",
        "text_widget_class": "CodeViewText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:37.730593",
        "tags": "None",
        "text": "r"
    },
    {
        "text_widget_id": 1970638992,
        "index": "18.4",
        "text_widget_class": "CodeViewText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:38.228814",
        "tags": "None",
        "text": "i"
    },
    {
        "index1": "18.4",
        "sequence": "TextDelete",
        "text_widget_class": "CodeViewText",
        "time": "2018-07-19T21:12:38.756270",
        "text_widget_id": 1970638992,
        "index2": "None"
    },
    {
        "text_widget_id": 1970638992,
        "index": "18.4",
        "text_widget_class": "CodeViewText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:39.020449",
        "tags": "None",
        "text": "u"
    },
    {
        "text_widget_id": 1970638992,
        "index": "18.5",
        "text_widget_class": "CodeViewText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:39.830837",
        "tags": "None",
        "text": "n"
    },
    {
        "text_widget_id": 1970638992,
        "index": "18.6",
        "text_widget_class": "CodeViewText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:40.085703",
        "tags": "None",
        "text": " "
    },
    {
        "text_widget_id": 1970638992,
        "index": "18.7",
        "text_widget_class": "CodeViewText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:40.329750",
        "tags": "None",
        "text": "s"
    },
    {
        "text_widget_id": 1970638992,
        "index": "18.8",
        "text_widget_class": "CodeViewText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:40.471521",
        "tags": "None",
        "text": "e"
    },
    {
        "text_widget_id": 1970638992,
        "index": "18.9",
        "text_widget_class": "CodeViewText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:40.722007",
        "tags": "None",
        "text": "r"
    },
    {
        "text_widget_id": 1970638992,
        "index": "18.10",
        "text_widget_class": "CodeViewText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:41.668961",
        "tags": "None",
        "text": "v"
    },
    {
        "text_widget_id": 1970638992,
        "index": "18.11",
        "text_widget_class": "CodeViewText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:42.052564",
        "tags": "None",
        "text": "o"
    },
    {
        "text_widget_id": 1970638992,
        "index": "18.12",
        "text_widget_class": "CodeViewText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:42.330311",
        "tags": "None",
        "text": "."
    },
    {
        "text_widget_id": 1970638992,
        "index": "18.13",
        "text_widget_class": "CodeViewText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:42.540989",
        "tags": "None",
        "text": "p"
    },
    {
        "text_widget_id": 1970638992,
        "index": "18.14",
        "text_widget_class": "CodeViewText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:42.693714",
        "tags": "None",
        "text": "y"
    },
    {
        "sequence": "<Button-1>",
        "widget_class": "Button",
        "widget_id": 1970498704,
        "time": "2018-07-19T21:12:43.656314"
    },
    {
        "text_widget_id": 1970638992,
        "sequence": "Save",
        "text_widget_class": "CodeViewText",
        "editor_id": 1970556176,
        "time": "2018-07-19T21:12:43.749367",
        "filename": "/home/pi/socketserver.py",
        "editor_class": "Editor"
    },
    {
        "index1": "71.4",
        "sequence": "TextDelete",
        "text_widget_class": "ShellText",
        "time": "2018-07-19T21:12:43.757368",
        "text_widget_context": "shell",
        "text_widget_id": 1970495696,
        "index2": "72.0"
    },
    {
        "text_widget_id": 1970495696,
        "index": "71.4",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:43.760087",
        "tags": "('automagic', 'toplevel', 'command')",
        "text_widget_context": "shell",
        "text": "%Run socketserver.py\n"
    },
    {
        "index1": "72.0",
        "sequence": "TextDelete",
        "text_widget_class": "ShellText",
        "time": "2018-07-19T21:12:43.768970",
        "text_widget_context": "shell",
        "text_widget_id": 1970495696,
        "index2": "72.0"
    },
    {
        "sequence": "MagicCommand",
        "cmd_line": "%Run socketserver.py\n",
        "time": "2018-07-19T21:12:43.771896"
    },
    {
        "command_text": "%Run socketserver.py\n",
        "sequence": "ShellCommand",
        "time": "2018-07-19T21:12:44.111916"
    },
    {
        "text_widget_id": 1970495696,
        "index": "72.0",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:44.118261",
        "tags": "('toplevel', 'error')",
        "text_widget_context": "shell",
        "text": "  "
    },
    {
        "text_widget_id": 1970495696,
        "index": "72.2",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:44.119895",
        "tags": "('toplevel', 'error', 'hyperlink')",
        "text_widget_context": "shell",
        "text": "File \"/home/pi/socketserver.py\", line 18"
    },
    {
        "text_widget_id": 1970495696,
        "index": "72.42",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:44.121936",
        "tags": "('toplevel', 'error')",
        "text_widget_context": "shell",
        "text": "\n"
    },
    {
        "text_widget_id": 1970495696,
        "index": "73.0",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:44.123261",
        "tags": "('toplevel', 'error')",
        "text_widget_context": "shell",
        "text": "    $run servo.py\n"
    },
    {
        "text_widget_id": 1970495696,
        "index": "74.0",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:44.124344",
        "tags": "('toplevel', 'error')",
        "text_widget_context": "shell",
        "text": "    ^\n"
    },
    {
        "text_widget_id": 1970495696,
        "index": "75.0",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:44.125346",
        "tags": "('toplevel', 'error')",
        "text_widget_context": "shell",
        "text": "SyntaxError: invalid syntax\n"
    },
    {
        "text_widget_id": 1970495696,
        "index": "76.0",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:44.126321",
        "tags": "('toplevel', 'error')",
        "text_widget_context": "shell",
        "text": "\n"
    },
    {
        "text_widget_id": 1970495696,
        "index": "77.0",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:44.127740",
        "tags": "('toplevel', 'prompt')",
        "text_widget_context": "shell",
        "text": ">>> "
    },
    {
        "text_widget_id": 1970638992,
        "sequence": "<Button-1>",
        "text_widget_class": "CodeViewText",
        "widget_id": 1970638992,
        "time": "2018-07-19T21:12:48.367030",
        "widget_class": "CodeViewText"
    },
    {
        "index1": "18.2",
        "sequence": "TextDelete",
        "text_widget_class": "CodeViewText",
        "time": "2018-07-19T21:12:50.607982",
        "text_widget_id": 1970638992,
        "index2": "18.3"
    },
    {
        "text_widget_id": 1970638992,
        "index": "18.2",
        "text_widget_class": "CodeViewText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:50.617077",
        "tags": "None",
        "text": "%"
    },
    {
        "sequence": "<Button-1>",
        "widget_class": "Button",
        "widget_id": 1970498704,
        "time": "2018-07-19T21:12:51.793553"
    },
    {
        "text_widget_id": 1970638992,
        "sequence": "Save",
        "text_widget_class": "CodeViewText",
        "editor_id": 1970556176,
        "time": "2018-07-19T21:12:51.952334",
        "filename": "/home/pi/socketserver.py",
        "editor_class": "Editor"
    },
    {
        "index1": "77.4",
        "sequence": "TextDelete",
        "text_widget_class": "ShellText",
        "time": "2018-07-19T21:12:51.961657",
        "text_widget_context": "shell",
        "text_widget_id": 1970495696,
        "index2": "78.0"
    },
    {
        "text_widget_id": 1970495696,
        "index": "77.4",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:51.964709",
        "tags": "('automagic', 'toplevel', 'command')",
        "text_widget_context": "shell",
        "text": "%Run socketserver.py\n"
    },
    {
        "index1": "78.0",
        "sequence": "TextDelete",
        "text_widget_class": "ShellText",
        "time": "2018-07-19T21:12:51.971596",
        "text_widget_context": "shell",
        "text_widget_id": 1970495696,
        "index2": "78.0"
    },
    {
        "sequence": "MagicCommand",
        "cmd_line": "%Run socketserver.py\n",
        "time": "2018-07-19T21:12:51.974450"
    },
    {
        "command_text": "%Run socketserver.py\n",
        "sequence": "ShellCommand",
        "time": "2018-07-19T21:12:52.312656"
    },
    {
        "text_widget_id": 1970495696,
        "index": "78.0",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:52.318986",
        "tags": "('toplevel', 'error')",
        "text_widget_context": "shell",
        "text": "  "
    },
    {
        "text_widget_id": 1970495696,
        "index": "78.2",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:52.320676",
        "tags": "('toplevel', 'error', 'hyperlink')",
        "text_widget_context": "shell",
        "text": "File \"/home/pi/socketserver.py\", line 18"
    },
    {
        "text_widget_id": 1970495696,
        "index": "78.42",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:52.322620",
        "tags": "('toplevel', 'error')",
        "text_widget_context": "shell",
        "text": "\n"
    },
    {
        "text_widget_id": 1970495696,
        "index": "79.0",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:52.323798",
        "tags": "('toplevel', 'error')",
        "text_widget_context": "shell",
        "text": "    %run servo.py\n"
    },
    {
        "text_widget_id": 1970495696,
        "index": "80.0",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:52.324812",
        "tags": "('toplevel', 'error')",
        "text_widget_context": "shell",
        "text": "    ^\n"
    },
    {
        "text_widget_id": 1970495696,
        "index": "81.0",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:52.325784",
        "tags": "('toplevel', 'error')",
        "text_widget_context": "shell",
        "text": "SyntaxError: invalid syntax\n"
    },
    {
        "text_widget_id": 1970495696,
        "index": "82.0",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:52.326733",
        "tags": "('toplevel', 'error')",
        "text_widget_context": "shell",
        "text": "\n"
    },
    {
        "text_widget_id": 1970495696,
        "index": "83.0",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:12:52.328140",
        "tags": "('toplevel', 'prompt')",
        "text_widget_context": "shell",
        "text": ">>> "
    },
    {
        "text_widget_id": 1970638992,
        "sequence": "<Button-1>",
        "text_widget_class": "CodeViewText",
        "widget_id": 1970638992,
        "time": "2018-07-19T21:12:57.595602",
        "widget_class": "CodeViewText"
    },
    {
        "index1": "18.2",
        "sequence": "TextDelete",
        "text_widget_class": "CodeViewText",
        "time": "2018-07-19T21:13:00.409504",
        "text_widget_id": 1970638992,
        "index2": "18.15"
    },
    {
        "text_widget_id": 1970638992,
        "index": "18.2",
        "text_widget_class": "CodeViewText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:13:00.417469",
        "tags": "None",
        "text": "f"
    },
    {
        "text_widget_id": 1970638992,
        "index": "18.3",
        "text_widget_class": "CodeViewText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:13:01.129203",
        "tags": "None",
        "text": "u"
    },
    {
        "text_widget_id": 1970638992,
        "index": "18.4",
        "text_widget_class": "CodeViewText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:13:02.680719",
        "tags": "None",
        "text": "n"
    },
    {
        "text_widget_id": 1970638992,
        "index": "18.5",
        "text_widget_class": "CodeViewText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:13:03.169565",
        "tags": "None",
        "text": "c"
    },
    {
        "text_widget_id": 1970638992,
        "index": "18.6",
        "text_widget_class": "CodeViewText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:13:03.348672",
        "tags": "None",
        "text": "t"
    },
    {
        "text_widget_id": 1970638992,
        "index": "18.7",
        "text_widget_class": "CodeViewText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:13:03.478218",
        "tags": "None",
        "text": "i"
    },
    {
        "text_widget_id": 1970638992,
        "index": "18.8",
        "text_widget_class": "CodeViewText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:13:03.680580",
        "tags": "None",
        "text": "o"
    },
    {
        "text_widget_id": 1970638992,
        "index": "18.9",
        "text_widget_class": "CodeViewText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:13:03.904451",
        "tags": "None",
        "text": "n"
    },
    {
        "text_widget_id": 1970638992,
        "index": "18.10",
        "text_widget_class": "CodeViewText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:13:04.050960",
        "tags": "None",
        "text": "s"
    },
    {
        "text_widget_id": 1970638992,
        "index": "18.11",
        "text_widget_class": "CodeViewText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:13:05.342481",
        "tags": "None",
        "text": "."
    },
    {
        "sequence": "<Button-1>",
        "widget_class": "EditorNotebook",
        "widget_id": 1970459376,
        "time": "2018-07-19T21:13:11.335041"
    },
    {
        "sequence": "<Button-1>",
        "widget_class": "EditorNotebook",
        "widget_id": 1970459376,
        "time": "2018-07-19T21:13:12.066743"
    },
    {
        "text_widget_id": 1970638992,
        "sequence": "<Button-1>",
        "text_widget_class": "CodeViewText",
        "widget_id": 1970638992,
        "time": "2018-07-19T21:13:13.186785",
        "widget_class": "CodeViewText"
    },
    {
        "text_widget_id": 1970638992,
        "index": "18.12",
        "text_widget_class": "CodeViewText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:13:13.512600",
        "tags": "None",
        "text": "s"
    },
    {
        "text_widget_id": 1970638992,
        "index": "18.13",
        "text_widget_class": "CodeViewText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:13:13.640860",
        "tags": "None",
        "text": "e"
    },
    {
        "text_widget_id": 1970638992,
        "index": "18.14",
        "text_widget_class": "CodeViewText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:13:13.795882",
        "tags": "None",
        "text": "r"
    },
    {
        "text_widget_id": 1970638992,
        "index": "18.15",
        "text_widget_class": "CodeViewText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:13:13.997014",
        "tags": "None",
        "text": "v"
    },
    {
        "text_widget_id": 1970638992,
        "index": "18.16",
        "text_widget_class": "CodeViewText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:13:14.202428",
        "tags": "None",
        "text": "o"
    },
    {
        "text_widget_id": 1970638992,
        "index": "18.17",
        "text_widget_class": "CodeViewText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:13:14.483397",
        "tags": "None",
        "text": "("
    },
    {
        "text_widget_id": 1970638992,
        "index": "18.18",
        "text_widget_class": "CodeViewText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:13:14.959334",
        "tags": "None",
        "text": "_"
    },
    {
        "index1": "18.18",
        "sequence": "TextDelete",
        "text_widget_class": "CodeViewText",
        "time": "2018-07-19T21:13:15.366168",
        "text_widget_id": 1970638992,
        "index2": "None"
    },
    {
        "text_widget_id": 1970638992,
        "index": "18.18",
        "text_widget_class": "CodeViewText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:13:15.567289",
        "tags": "None",
        "text": ")"
    },
    {
        "sequence": "<Button-1>",
        "widget_class": "Button",
        "widget_id": 1970498704,
        "time": "2018-07-19T21:13:17.457907"
    },
    {
        "text_widget_id": 1970638992,
        "sequence": "Save",
        "text_widget_class": "CodeViewText",
        "editor_id": 1970556176,
        "time": "2018-07-19T21:13:17.548295",
        "filename": "/home/pi/socketserver.py",
        "editor_class": "Editor"
    },
    {
        "index1": "83.4",
        "sequence": "TextDelete",
        "text_widget_class": "ShellText",
        "time": "2018-07-19T21:13:17.552782",
        "text_widget_context": "shell",
        "text_widget_id": 1970495696,
        "index2": "84.0"
    },
    {
        "text_widget_id": 1970495696,
        "index": "83.4",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:13:17.554348",
        "tags": "('automagic', 'toplevel', 'command')",
        "text_widget_context": "shell",
        "text": "%Run socketserver.py\n"
    },
    {
        "index1": "84.0",
        "sequence": "TextDelete",
        "text_widget_class": "ShellText",
        "time": "2018-07-19T21:13:17.557587",
        "text_widget_context": "shell",
        "text_widget_id": 1970495696,
        "index2": "84.0"
    },
    {
        "sequence": "MagicCommand",
        "cmd_line": "%Run socketserver.py\n",
        "time": "2018-07-19T21:13:17.558977"
    },
    {
        "command_text": "%Run socketserver.py\n",
        "sequence": "ShellCommand",
        "time": "2018-07-19T21:13:17.861645"
    },
    {
        "text_widget_id": 1970495696,
        "index": "84.0",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:13:17.917739",
        "tags": "('io', 'stdout', 'vertically_spaced')",
        "text_widget_context": "shell",
        "text": "S"
    },
    {
        "text_widget_id": 1970495696,
        "index": "84.1",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:13:17.919353",
        "tags": "('io', 'stdout')",
        "text_widget_context": "shell",
        "text": "ocket created\nSocket bind complete\nSocket now listening\n"
    },
    {
        "text_widget_id": 1970638992,
        "sequence": "<Button-1>",
        "text_widget_class": "CodeViewText",
        "widget_id": 1970638992,
        "time": "2018-07-19T21:13:18.764182",
        "widget_class": "CodeViewText"
    },
    {
        "sequence": "Command",
        "command_id": "save_file",
        "denied": "True",
        "time": "2018-07-19T21:13:19.027311"
    },
    {
        "text_widget_id": 1970638992,
        "sequence": "<Button-1>",
        "text_widget_class": "CodeViewText",
        "widget_id": 1970638992,
        "time": "2018-07-19T21:13:19.764819",
        "widget_class": "CodeViewText"
    },
    {
        "text_widget_id": 1970638992,
        "sequence": "<Button-1>",
        "text_widget_class": "CodeViewText",
        "widget_id": 1970638992,
        "time": "2018-07-19T21:13:21.437402",
        "widget_class": "CodeViewText"
    },
    {
        "text_widget_id": 1970638992,
        "sequence": "<Button-1>",
        "text_widget_class": "CodeViewText",
        "widget_id": 1970638992,
        "time": "2018-07-19T21:13:21.645748",
        "widget_class": "CodeViewText"
    },
    {
        "text_widget_id": 1970638992,
        "sequence": "<Button-1>",
        "text_widget_class": "CodeViewText",
        "widget_id": 1970638992,
        "time": "2018-07-19T21:13:22.350335",
        "widget_class": "CodeViewText"
    },
    {
        "text_widget_id": 1970638992,
        "sequence": "<Button-1>",
        "text_widget_class": "CodeViewText",
        "widget_id": 1970638992,
        "time": "2018-07-19T21:13:23.454438",
        "widget_class": "CodeViewText"
    },
    {
        "sequence": "Command",
        "command_id": "save_file",
        "denied": "True",
        "time": "2018-07-19T21:13:23.737704"
    },
    {
        "text_widget_id": 1970638992,
        "sequence": "<Button-1>",
        "text_widget_class": "CodeViewText",
        "widget_id": 1970638992,
        "time": "2018-07-19T21:13:24.407013",
        "widget_class": "CodeViewText"
    },
    {
        "text_widget_id": 1970638992,
        "sequence": "<Button-1>",
        "text_widget_class": "CodeViewText",
        "widget_id": 1970638992,
        "time": "2018-07-19T21:13:25.569152",
        "widget_class": "CodeViewText"
    },
    {
        "text_widget_id": 1970495696,
        "sequence": "<Button-1>",
        "text_widget_class": "ShellText",
        "widget_id": 1970495696,
        "time": "2018-07-19T21:13:25.943202",
        "widget_class": "ShellText",
        "text_widget_context": "shell"
    },
    {
        "text_widget_id": 1970638992,
        "sequence": "<Button-1>",
        "text_widget_class": "CodeViewText",
        "widget_id": 1970638992,
        "time": "2018-07-19T21:13:28.928117",
        "widget_class": "CodeViewText"
    },
    {
        "sequence": "<Button-1>",
        "widget_class": "Frame",
        "widget_id": 1971011376,
        "time": "2018-07-19T21:13:29.823570"
    },
    {
        "sequence": "<Button-1>",
        "widget_class": "Button",
        "widget_id": 1970499248,
        "time": "2018-07-19T21:13:29.866578"
    },
    {
        "sequence": "<Button-1>",
        "widget_class": "EditorNotebook",
        "widget_id": 1970459376,
        "time": "2018-07-19T21:13:29.886200"
    },
    {
        "text_widget_id": 1970495696,
        "index": "87.0",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:13:29.904798",
        "tags": "('io', 'stderr')",
        "text_widget_context": "shell",
        "text": "Traceback (most recent call last):\n"
    },
    {
        "text_widget_id": 1970495696,
        "index": "88.0",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:13:29.905985",
        "tags": "('io', 'stderr')",
        "text_widget_context": "shell",
        "text": "  "
    },
    {
        "text_widget_id": 1970495696,
        "index": "88.2",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:13:29.907011",
        "tags": "('io', 'stderr', 'hyperlink')",
        "text_widget_context": "shell",
        "text": "File \"/home/pi/socketserver.py\", line 29, in <module>"
    },
    {
        "text_widget_id": 1970495696,
        "index": "88.55",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:13:29.907990",
        "tags": "('io', 'stderr')",
        "text_widget_context": "shell",
        "text": "\n"
    },
    {
        "text_widget_id": 1970495696,
        "index": "89.0",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:13:29.908972",
        "tags": "('io', 'stderr')",
        "text_widget_context": "shell",
        "text": "    conn, addr = s.accept()\n"
    },
    {
        "text_widget_id": 1970495696,
        "index": "90.0",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:13:29.909965",
        "tags": "('io', 'stderr')",
        "text_widget_context": "shell",
        "text": "  "
    },
    {
        "text_widget_id": 1970495696,
        "index": "90.2",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:13:29.910992",
        "tags": "('io', 'stderr', 'hyperlink')",
        "text_widget_context": "shell",
        "text": "File \"/usr/lib/python3.5/socket.py\", line 195, in accept"
    },
    {
        "text_widget_id": 1970495696,
        "index": "90.58",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:13:29.912063",
        "tags": "('io', 'stderr')",
        "text_widget_context": "shell",
        "text": "\n"
    },
    {
        "text_widget_id": 1970495696,
        "index": "91.0",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:13:29.913063",
        "tags": "('io', 'stderr')",
        "text_widget_context": "shell",
        "text": "    fd, addr = self._accept()\n"
    },
    {
        "text_widget_id": 1970495696,
        "index": "92.0",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:13:29.914017",
        "tags": "('io', 'stderr')",
        "text_widget_context": "shell",
        "text": "KeyboardInterrupt: Execution interrupted\n"
    },
    {
        "text_widget_id": 1970495696,
        "index": "93.0",
        "text_widget_class": "ShellText",
        "sequence": "TextInsert",
        "time": "2018-07-19T21:13:29.918397",
        "tags": "('toplevel', 'prompt', 'vertically_spaced')",
        "text_widget_context": "shell",
        "text": ">>> "
    },
    {
        "text_widget_id": 1970638992,
        "sequence": "<Button-1>",
        "text_widget_class": "CodeViewText",
        "widget_id": 1970638992,
        "time": "2018-07-19T21:13:30.594137",
        "widget_class": "CodeViewText"
    },
    {
        "text_widget_id": 1970638992,
        "sequence": "<Button-1>",
        "text_widget_class": "CodeViewText",
        "widget_id": 1970638992,
        "time": "2018-07-19T21:13:37.735383",
        "widget_class": "CodeViewText"
    },
    {
        "text_widget_id": 1970638992,
        "sequence": "<Button-1>",
        "text_widget_class": "CodeViewText",
        "widget_id": 1970638992,
        "time": "2018-07-19T21:13:37.937951",
        "widget_class": "CodeViewText"
    },
    {
        "text_widget_id": 1970638992,
        "sequence": "<Button-1>",
        "text_widget_class": "CodeViewText",
        "widget_id": 1970638992,
        "time": "2018-07-19T21:13:42.320437",
        "widget_class": "CodeViewText"
    },
    {
        "text_widget_id": 1970638992,
        "sequence": "<Button-1>",
        "text_widget_class": "CodeViewText",
        "widget_id": 1970638992,
        "time": "2018-07-19T21:13:42.561229",
        "widget_class": "CodeViewText"
    },
    {
        "text_widget_id": 1970638992,
        "sequence": "<Button-1>",
        "text_widget_class": "CodeViewText",
        "widget_id": 1970638992,
        "time": "2018-07-19T21:13:42.960436",
        "widget_class": "CodeViewText"
    },
    {
        "text_widget_id": 1970638992,
        "sequence": "<Button-1>",
        "text_widget_class": "CodeViewText",
        "widget_id": 1970638992,
        "time": "2018-07-19T21:13:43.590766",
        "widget_class": "CodeViewText"
    },
    {
        "text_widget_id": 1970638992,
        "sequence": "<Button-1>",
        "text_widget_class": "CodeViewText",
        "widget_id": 1970638992,
        "time": "2018-07-19T21:13:44.286925",
        "widget_class": "CodeViewText"
    },
    {
        "text_widget_id": 1970638992,
        "sequence": "<Button-1>",
        "text_widget_class": "CodeViewText",
        "widget_id": 1970638992,
        "time": "2018-07-19T21:13:44.894793",
        "widget_class": "CodeViewText"
    },
    {
        "text_widget_id": 1970638992,
        "sequence": "<Button-1>",
        "text_widget_class": "CodeViewText",
        "widget_id": 1970638992,
        "time": "2018-07-19T21:13:47.976962",
        "widget_class": "CodeViewText"
    },
    {
        "text_widget_id": 1970638992,
        "sequence": "<Button-1>",
        "text_widget_class": "CodeViewText",
        "widget_id": 1970638992,
        "time": "2018-07-19T21:13:50.088297",
        "widget_class": "CodeViewText"
    },
    {
        "text_widget_id": 1970638992,
        "sequence": "<Button-1>",
        "text_widget_class": "CodeViewText",
        "widget_id": 1970638992,
        "time": "2018-07-19T21:13:50.418476",
        "widget_class": "CodeViewText"
    }
]